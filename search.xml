<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>9月18笔试算法(中等)</title>
    <url>/2021/09/18/9%E6%9C%8818%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>划分数组为和相等的两个非空子集</p>
<p>输入：[1,2,3,4,6,7,8,9]</p>
<p>输出：true</p>
<p>说明：[1,2,3,4,6,7,8,9]可分为[1,4,6,9]和[2,3,7,8]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>当数组长度n&lt;2时，不能将数组分割成元素和相等的两个子集，直接返回false。</li>
<li>当整个数组的元素和sum为奇数时直接返回false。</li>
<li>当最大元素maxNum大于sum/2时，maxNum以外的所有元素和一定小于sum/2，所以不可能将数组分成两个和相等的子集，直接返回false（如[1,5,5,13]，sum/2=12，maxNum=13，此时剩下的加起来都小于sum/2）</li>
<li>创建二维数组dp，包含n行sum/2列，其中dp[i] [j]表示从数组的[0,i]下标选取若干个正整数（可以是0个），是否存在一种选取方案使得被选取的正整数的和等于j。其数组初始值都为false。</li>
<li>当不选取任何正整数，对应0&lt;=i&lt;n，dp[i] [0]=true。</li>
<li>当i == 0，只有一个nums[0]可被选取，因此dp[0] [nums[0]] = true。</li>
<li>当j &gt;= nums[i]，对于当前数字nums[i]可以被选取也可以不被选取，两种情况只要一种为true就有dp[i] [j]=true。当不选取nums[i]时，dp[i] [j] = dp[i-1] [j]；当选取nums[i]，则dp[i] [j] = dp[i-1] [j-nums[i]]。</li>
<li>当j &lt; nums[i]，则在选取数字和等于j的情况下无法选取当前的数字nums[i]，因此有dp[i] [j] = dp[i-1] [j]；</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSplit</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxNum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= num)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] | dp[i-<span class="number">1</span>][j-num];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包问题</title>
    <url>/2021/09/27/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>输入：W=4，N=3，wt[i]=[2,1,3]，val[4,2,3]</p>
<p>输出：6</p>
<blockquote>
<p>定义：dp[i] [w]表示前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是d[i] [w]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W,<span class="keyword">int</span> N,<span class="keyword">int</span>[] wt,<span class="keyword">int</span>[] val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//重量为0时最大价值为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= N;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//物品个数为0是最大价值为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= W;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>;w &lt;= W;w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w - wt[i-<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//装不下第i个物品(第i个物品的wt其下标为i-1)</span></span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//选择装第i个物品或者不装第i个物品</span></span><br><span class="line">                dp[i][w] = Math.max(dp[i-<span class="number">1</span>][w],dp[i-<span class="number">1</span>][w-wt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>9月23笔试算法(简单)</title>
    <url>/2021/09/23/9%E6%9C%8823%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<p>难受，这题是约瑟夫问题的变形，写的时候一直没完全弄清逻辑，结果通过率只有10%</p>
<p>输入：3 5</p>
<p>输出：1</p>
<p>说明：3是初始报数，5是5个人，序号为1,2,3,4,5。然后报到3的出列，下一次从出列的下一个人开始报数，并且报数累加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yuesefu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">yuesefu</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index + m) % list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">            <span class="comment">//下一个人开始</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">//报数加1</span></span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>9月24面试查漏补缺</title>
    <url>/2021/09/24/9%E6%9C%8824%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h3 id="包装类了解？Integer为什么超过127不能用-比较，其底层原理是什么"><a href="#包装类了解？Integer为什么超过127不能用-比较，其底层原理是什么" class="headerlink" title="包装类了解？Integer为什么超过127不能用==比较，其底层原理是什么"></a>包装类了解？Integer为什么超过127不能用==比较，其底层原理是什么</h3><blockquote>
<p>Integer类内部通过静态内部类提供了一个缓存池，范围在-128~127之间，如果超过这个范围 Integer 值都是new出来的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (IntegerCache.high &gt;= <span class="number">127</span>);</span><br><span class="line">        <span class="keyword">if</span> ((paramInt &gt;= -<span class="number">128</span>) &amp;&amp; (paramInt &lt;= IntegerCache.high))</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[(paramInt + <span class="number">128</span>)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(paramInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile有什么特性？每个特性是怎么实现的？没有volatile多线程访问变量内部实现又是怎么样的？"><a href="#volatile有什么特性？每个特性是怎么实现的？没有volatile多线程访问变量内部实现又是怎么样的？" class="headerlink" title="volatile有什么特性？每个特性是怎么实现的？没有volatile多线程访问变量内部实现又是怎么样的？"></a>volatile有什么特性？每个特性是怎么实现的？没有volatile多线程访问变量内部实现又是怎么样的？</h3><blockquote>
<p>volatile特性：保证有序性、可见性</p>
<p><strong>有序性原理：</strong></p>
<p>通过插入内存屏障来禁止指令重排。</p>
<p><strong>可见性原理：</strong></p>
<ol>
<li><p>每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。 </p>
</li>
<li><p>当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态</p>
</li>
</ol>
</blockquote>
<p><strong>java内存模型：</strong></p>
<p>Java内存模型的一个抽象概念，它包含了控制器、运算器、缓存等，本地内存并不是真实存在的。同时Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这种内存模型会出现什么问题呢？，</p>
<blockquote>
<p>|线程A|。。。。。。|线程B|</p>
<p>↓。。。。。。。。。。↓</p>
<p>|本地内存A|。。。|本地内存B|</p>
<p>↓。。。。。。。。。。↓ </p>
<p>—————-主内存—————-</p>
<p>​    共享变量X</p>
<p>—————-主内存—————-</p>
</blockquote>
<blockquote>
<ol>
<li>线程A获取到共享变量X的值，此时本地内存A中没有X的值，所以加载主内存中的X值并缓存到本地内存A中，线程A修改X的值为1，并将X的值刷新到主内存中，这时主内存及本地内存中的X的值都为1。 </li>
<li>线程B需要获取共享变量X的值，此时本地内存B中没有X的值，加载主内存中的X值并缓存到本地内存B中，此时X的值为1。线程B修改X的值为2，并刷新到主内存中，此时主内存及本地内存B中的X值为2，本地内存A中的X值为1。 </li>
<li>线程A再次获取共享变量X的值，此时本地内存中存在X的值，所以直接从本地内存中A获取到了X为1的值，但此时主内存中X的值为2，到此出现了所谓内存不可见的问题。</li>
</ol>
</blockquote>
<h3 id="Linux中查询一个文件的某个字符怎么实现？"><a href="#Linux中查询一个文件的某个字符怎么实现？" class="headerlink" title="Linux中查询一个文件的某个字符怎么实现？"></a>Linux中查询一个文件的某个字符怎么实现？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep “要查找的字符串” 文件名</span><br></pre></td></tr></table></figure>

<h3 id="Linux中怎么将日志文件内容实时打印到控制台"><a href="#Linux中怎么将日志文件内容实时打印到控制台" class="headerlink" title="Linux中怎么将日志文件内容实时打印到控制台"></a>Linux中怎么将日志文件内容实时打印到控制台</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f xxx.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tail参数：</p>
<p>-f 循环读取</p>
<p>-q 不显示处理信息</p>
<p>-v 显示详细的处理信息</p>
<p>-c&lt;数目&gt; 显示的字节数</p>
<p>-n&lt;行数&gt; 显示文件的尾部 n 行内容</p>
<p>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束</p>
<p>-q, –quiet, –silent 从不输出给出文件名的首部</p>
<p>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</p>
</blockquote>
<h3 id="Map使用put过程是怎么样的？为什么实际使用更多地用String类型来当key？"><a href="#Map使用put过程是怎么样的？为什么实际使用更多地用String类型来当key？" class="headerlink" title="Map使用put过程是怎么样的？为什么实际使用更多地用String类型来当key？"></a>Map使用put过程是怎么样的？为什么实际使用更多地用String类型来当key？</h3><p><strong>put的过程：</strong></p>
<blockquote>
<ol>
<li>HashMap底层是使用Entry对象数组存储的，而Entry是一个单项的链表，当调用一个put方法将一个键值对添加进来时先使用hash函数获取该对象的hash值。</li>
<li>然后调用indexFor方法查找该对象在数组中应该存储的下标。</li>
<li>如果该位置为空，就将value值插入。</li>
<li>如果该下标下不为空，如果这两个Entry的key通过equals比较返回true，新Entry的value将覆盖原有Entry的value，但key不会覆盖。</li>
<li>如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有的Entry形成Entry链，而且新添加的Enetry位于Entry链的头部。</li>
</ol>
</blockquote>
<p><strong>String类型当key：</strong></p>
<blockquote>
<ol>
<li>String 对象的 hashCode() 值是根据 String 对象的内容计算的，并不是根据对象的地址计算；</li>
<li>String不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。即使非String对象重写了hashCode和equals 方法也，不如String高效，因为String中缓存有个hash变量，它可以缓存hashCode，避免重复计算hashCode。</li>
</ol>
</blockquote>
<h3 id="使用TreeSet时对自定义对象排序怎么实现？"><a href="#使用TreeSet时对自定义对象排序怎么实现？" class="headerlink" title="使用TreeSet时对自定义对象排序怎么实现？"></a>使用TreeSet时对自定义对象排序怎么实现？</h3><p><strong>自然排序（使用空参构造）：</strong></p>
<p>自定义类实现Comparable接口，并重写compareTo方法后，直接使用TreeSet对象进行添加。</p>
<p><strong>比较器排序（使用有参构造）：</strong></p>
<p>另外提供一个实现了Comparator的接口的类，在new TreeSet时传入类对象。或直接使用匿名内部类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Person&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Mycompare());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="comment">//采用匿名内部类传入比较器对象；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Comparable和Comparator的区别：</strong></p>
<blockquote>
<p>Comparable来自java.lang包，Comparator来自java.util包</p>
<p>很多常用类都实现了Comparable接口，像Integer、String等，所以直接调用Collection.sort直接可以使用。当对类自带的自然排序不满意而又不能修改其源代码的情况，使用Comparator比较合适。</p>
<p>使用Comparator可以避免添加额外的代码与我们的目标类耦合，同时可以定义多种排序规则，这一点Comparable无法做到。</p>
</blockquote>
<h3 id="BIO，NIO，AIO？"><a href="#BIO，NIO，AIO？" class="headerlink" title="BIO，NIO，AIO？"></a>BIO，NIO，AIO？</h3><p><strong>BIO(blocking I/O)：</strong></p>
<p>同步阻塞IO，使用BIO当前线程只能进行IO操作。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善。</p>
<p><strong>NIO (non-blocking I/O)：</strong></p>
<p>同步非阻塞IO，基于Reactor模型。NIO利用了单线程轮询事件机制。服务器实现模式为一个请求一个线程，即客户端发生的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。</p>
<blockquote>
<p>应用场景：聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持</p>
</blockquote>
<p><strong>AIO(Asynchronous I/O) ：</strong></p>
<p>异步非阻塞IO，基于Proactor模型的。它不是在IO准备好时再通知线程，而是在IO操作已经完成以后由操作系统再给线程发出通知。因此AIO是不会阻塞的。服务器实现模式为一个有效请求一个线程。</p>
<blockquote>
<p>应用场景：相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>9月23笔试查漏补缺</title>
    <url>/2021/09/23/9%E6%9C%8823%E7%AC%94%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>使当前线程进入指定毫秒数的休眠，暂停执行，需要处理InterruptedException。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁</p>
<h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><blockquote>
<ol>
<li>wait()是Object的方法，sleep()是Thread的方法</li>
<li>sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</li>
<li>wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</li>
<li>sleep 方法没有释放锁，而 wait 方法释放了锁 。</li>
<li>sleep 通常被用于暂停执行，wait 通常被用于线程间交互/通信</li>
<li>sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法</li>
</ol>
</blockquote>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><p>唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</p>
<h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><p>唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote>
<ol>
<li>客户端发送标志位SYN=1，序列号seq=a的数据段，SYN报文不能携带数据，但要消耗一个序列号。</li>
<li>服务器回复SYN，ACK=1，seq=b，ack=a+1数据段确认。</li>
<li>客户端发送ACK=1，seq=a+1，ack=b+1报文段对服务器SYN数据段确认</li>
</ol>
</blockquote>
<p><strong>拓展：两次握手不行吗？</strong></p>
<blockquote>
<p><strong>主要校验：客户端发送能力、客户端接收能力、服务端发送能力、服务端接收能力。</strong></p>
<p>第一次握手：客户端发送，服务端收到。服务端可以得出结论：客户端发送能力正常、服务端接收能力正常。</p>
<p>第二次握手：服务端发送，客户端收到。客户端可以得出结论：服务端发送和接收能力正常、客户端发送和接收能力正常。此时只剩下服务端还不知道客户端接收能力是否正常。</p>
<p>第三次握手：客户端发送，服务端收到。最后服务端得出结论：客户端发送和接收正常，服务端自己发送和接收也正常。</p>
</blockquote>
<p><strong>如果只使用两次握手可能会出现：</strong></p>
<blockquote>
<p>如果客户端发送连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。然后收到了确认，建立了连接。</p>
<p>完成数据传输后，就释放了连接，客户端共发送了两次请求报文段，其中一个丢失，第二个到服务端。但是可能第一个丢失的报文段只是在某些网络阶段长时间滞留了，延误到链接释放后的某个时间达到了服务端，此时服务端以为客户端又发了一次请求，于是就向客户端发送确认报文，同意连接。</p>
<p>不采用三次握手，只要服务端发出确认就建立新的连接，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送资源，造成资源浪费。</p>
</blockquote>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote>
<ol>
<li>客户端发送FIN，ACK=1，seq=m，ack=n数据段请求终止。此时客户端处于FIN_WAIT1(终止等待1)状态</li>
<li>服务器回复ACK=1，seq=n，ack=m+1数据段对客户端FIN报文确认。此时服务端进入CLOSE_WAIT状态，<strong>TCP处于半关闭状态，客户端到服务端的连接释放</strong>，客户端收到确认报文后进入FIN_WAIT2(终止等待2)状态。（这个阶段服务端还可以向客户端发送数据）</li>
<li>服务器发送FIN，ACK=1，seq=x，ack=m+1数据段请求连接。此时服务端进入LAST_ACK的状态。</li>
<li>客户端发送ACK=1，seq=m+1，ack=x+1的数据段对服务器FIN报文确认。此时客户端处于TIME_WAIT状态，需要经过等待计时器设置的实际2MSL后客户端才进入CLOSED状态，TCP连接才释放。</li>
</ol>
</blockquote>
<p><strong>为什么挥手需要四次？</strong></p>
<blockquote>
<p>因为当服务端收到客户端发来的FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等服务端所有报文都发送完了，才能发送FIN报文，因此不能像三次握手同时发送SYN+ACK报文那样发送FIN+ACK报文，因此需要四次挥手。</p>
</blockquote>
<h3 id="避免幻读"><a href="#避免幻读" class="headerlink" title="避免幻读"></a>避免幻读</h3><p>间隙锁。</p>
<p><strong>间隙锁概念：</strong></p>
<h3 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwxrwxrwx=777</span><br><span class="line">r：读</span><br><span class="line">w：写</span><br><span class="line">x：执行</span><br><span class="line">第一个rwx：u文件所有者的权限</span><br><span class="line">第二个rwx：g文件所属组用户权限</span><br><span class="line">第三个rwx：o其他用户</span><br></pre></td></tr></table></figure>

<h3 id="Linux标准输出"><a href="#Linux标准输出" class="headerlink" title="Linux标准输出"></a>Linux标准输出</h3><p>“&lt;”：标准输入重定向；</p>
<p>“&gt;”：覆盖方式标准输出重定向；</p>
<p>“&gt;&gt;”：追加方式标准输出重定向；</p>
<p>“&amp;&gt;”：标准输出和标准错误同时重定向；</p>
<p>“&amp;&gt;&gt;”：标准输出和标准错误同时重定向追加；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">覆盖方式，将当前目录信息重定向到文件/tmp/dir.out</span><br><span class="line">#ls &gt; /tmp/dir.out</span><br></pre></td></tr></table></figure>

<h3 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h3><p>Linux中环境变量包括系统级和用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，而用户级的环境变量则是该用户使用系统时加载的环境变量。</p>
<blockquote>
<p><strong>环境变量文件</strong></p>
<p>系统级：</p>
<p>/etc/profile（系统启动后第一个用户登录时运行，可以用于设定针对全系统所有用户的环境变量）</p>
<p>/etc/bashrc（bash shell 打开时运行，修改该文件配置的环境变量将会影响所有用户使用的bash shell）</p>
<p>/etc/environment（系统启动时运行，用于配置与系统运行相关但与用户无关的环境变量）</p>
<p>用户级：</p>
<p>~/.profile（每个用户都可以使用该文件来配置专属于自己使用的shell信息）</p>
<p>~/.bashrc（当用户登录时以及每次打开新的shell时该文件都将被读取）</p>
</blockquote>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p><strong>慢开始</strong></p>
<blockquote>
<p>慢开始算法就是在刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次报文都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。</p>
</blockquote>
<blockquote>
<p>过程：</p>
<p>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</p>
<p> 每当收到一个ACK，cwnd大小加一，呈线性上升。 </p>
<p> 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。</p>
<p>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”</p>
</blockquote>
<p><strong>拥塞控制</strong></p>
<blockquote>
<p>TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。</p>
<p>对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。</p>
</blockquote>
<p><strong>快重传</strong></p>
<blockquote>
<p>要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。</p>
</blockquote>
<p><strong>快恢复</strong></p>
<p>进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。</p>
<blockquote>
<p>快速恢复算法的逻辑如下：</p>
<p>cwnd = cwnd + 3 * MSS，加3 * MSS的原因是因为收到3个重复的ACK。</p>
<p>重传DACKs指定的数据包。</p>
<p>如果再收到DACKs，那么cwnd大小增加一。</p>
<p>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</p>
</blockquote>
<h3 id="4XX错误"><a href="#4XX错误" class="headerlink" title="4XX错误"></a>4XX错误</h3><p>400：服务器无法理解请求，因为语法无效。</p>
<p>401：请求要身份验证。对应登陆后请求的网页，服务器可能发货此响应。</p>
<p>404：服务器找不到请求的网页。</p>
<p>405：禁用请求中指定的方法。</p>
<p>406：无法使用请求的内容特性响应请求的网页。</p>
<p>407：需要代理授权。</p>
<p>408：服务器等待请求时发生超时。</p>
<h3 id="5XX错误"><a href="#5XX错误" class="headerlink" title="5XX错误"></a>5XX错误</h3><p>500：服务器遇到错误，无法完成请求。</p>
<p>501：服务器不具备完成请求的功能。例如：服务器无法识别请求方法时可能会返回此代码。</p>
<p>502：服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>503：服务器目前无法使用（由于超载或停机维护）。通常只是暂时的状态。</p>
<p>504：服务器作为网关或代理，但是没有及时从上游服务收到请求。</p>
<p>505：服务器不支持请求中所用的HTTP协议版本。</p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>9月2深夜总结</title>
    <url>/2021/09/02/9%E6%9C%882%E6%B7%B1%E5%A4%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​        回忆今天，早上上了一上午的课，然后下午在idea用git在码云上建立了远程仓库。由于之前只是通过敲命令去实现远程仓库同步，今天在idea上不用命令反而出现了一堆问题，不过最后也还是一一解决了这些问题并且加深了对git了解。傍晚，因为课设要和舍友一起做，也把git的使用方法教给了他，两人也互相测试了上传代码的一些疑惑。然后，好像今天只做了这一点东西…LeetCode每日一题没做，英语6级单词没背，Redis视频没看，框架没复习。</p>
<p>​        晚上看了看自己在网上的简历投递，昨天晚上才投的果然流程终止了，意料之内，还侥幸想着拿个笔试试试手。不过也还好，毕竟简历平平。10点多后，跟老伙计们电话聊天，还是原滋原味的快乐。在聊天过后也恢复了平静，重新思考了一些方向，刷道题就睡吧，记2021.09.02。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>9月8笔试算法(中等)</title>
    <url>/2021/09/09/9%E6%9C%888%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95-%E4%B8%AD%E7%AD%89/</url>
    <content><![CDATA[<p>哎，难受，笔试算法是最常见的“求最长公共子序列”，刷到就是白给那种。以前用C语言写过，过了一年了，忘得七七八八了，做题时都愣住了，只能简单推导一下就交了，过了67%的用例。</p>
<p>输入：“abcd” “acd”</p>
<p>输出：3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str1.length();</span><br><span class="line">        <span class="keyword">int</span> m = str2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row : memo)&#123;</span><br><span class="line">            Arrays.fill(row,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(str1,<span class="number">0</span>,str2,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1,<span class="keyword">int</span> i,String s2,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length() || j == s2.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记过了直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1,i+<span class="number">1</span>,s2,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = Math.max(dp(s1,i+<span class="number">1</span>,s2,j),dp(s1,i,s2,j+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>9月28笔试算法(简单)</title>
    <url>/2021/09/28/9%E6%9C%8828%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<p>输入一个数代表进制数，再输入两个当前进制的数，输出两个数在当前进制的和</p>
<p>输入：2 10 11</p>
<p>输出：101</p>
<p>说明：2表示2进制，10和11为2进制数相加</p>
<p>输入：3 10 11</p>
<p>输出：21</p>
<p>说明：3表示3进制，10和11为3进制数相加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>9月4笔试算法(简单)</title>
    <url>/2021/09/04/9%E6%9C%884%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<p>返回数组中的温度到集合，要求某个温度左边比它小，右边比它大，而且最左和最右的不输出。</p>
<p>输入：[0, 5, 11, 22, 15,14]</p>
<p>输出：[5.0, 11.0]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Double&gt; <span class="title">findPoints</span> <span class="params">(<span class="keyword">double</span>[] data)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Double&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> n = data.length;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j &gt; i;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(data[i] &gt;= data[j])&#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(data[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：我用了最简单的暴力方法，但是做题时脑抽，少了个else判断，导致数组中第二个温度比第一个小时还加到集合里，有一部分用例没过。</p>
<blockquote>
<p>比如：</p>
<p>输入：[0, -2.2, 11, 22, 15,-18]</p>
<p>输出：[]</p>
<p>刚开始时少了else{continue;}判断，就会输出[-2.2]</p>
</blockquote>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList实现动态数组原理</title>
    <url>/2022/03/01/ArrayList%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//用于记录list的修改次数，验证值有没有被修改</span></span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//elementData在调用ArrayList构造方法时，是否传入初始容量，传入就new Object[initialCapacity]赋值给elementData，没有赋值EMPTY_ELEMENTDATA(空数组)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DEFAULT_CAPACITY默认容量为10</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//原容量的3倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简述过程"><a href="#简述过程" class="headerlink" title="简述过程"></a>简述过程</h1><p>当调用add方法时会调用内部的add(E e, Object[] elementData, int s)，</p>
<p>当s等于elementData数组长度就要调用grow进行扩容，传递s+1，</p>
<p>然后在grow方法通过Arrays.copyOf进行新数组复制，</p>
<p>其中新数组的长度还有通过newCapacity进行获取。</p>
]]></content>
  </entry>
  <entry>
    <title>Arrays工具类</title>
    <url>/2021/09/05/Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Arrays类位于 java.util 包中，是一个工具类，主要包含了操作数组的各种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill()"></a>Arrays.fill()</h3><p><strong>填充数组</strong></p>
<p>将指定数组所有值填充为指定值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//新建一个大小为5的数组</span></span><br><span class="line">Arrays.fill(arr,<span class="number">4</span>);<span class="comment">//给所有值赋值4</span></span><br><span class="line">String str = Arrays.toString(arr);</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="comment">//输出：[4, 4, 4, 4, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//新建一个大小为5的数组</span></span><br><span class="line">Arrays.fill(arr,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//给第2位（0开始）到第4位（不包括）赋值6</span></span><br><span class="line">String str = Arrays.toString(arr);</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="comment">//输出：[0, 0, 6, 6, 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p><strong>数组排序</strong></p>
<p>对数组进行升序排列，利用这个方法可传入要排序的数组进去排序，因为传入的是一个数组的引用，所以排序完成的结果也通过这个引用来更改数组。数组中的数据类型必须实现Comparable接口。</p>
<p>1.数字排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">23</span> &#125;;</span><br><span class="line">Arrays.sort(intArray);</span><br><span class="line"><span class="comment">//输出： [-23, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>2.字符串排序，先大写后小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArray = <span class="keyword">new</span> String[] &#123; “z”, “a”, “C” &#125;;</span><br><span class="line">Arrays.sort(strArray);</span><br><span class="line"><span class="comment">//输出： [C, a, z]</span></span><br></pre></td></tr></table></figure>

<p>3.严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"><span class="comment">//输出： [a, C, z]</span></span><br></pre></td></tr></table></figure>

<p>4.反向排序， Reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"><span class="comment">//输出：[z, a, C]</span></span><br></pre></td></tr></table></figure>

<p>5.忽略大小写反向排序 Case-insensitive reverse-order sort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"><span class="comment">//输出： [z, C, a]</span></span><br></pre></td></tr></table></figure>

<p>6.选择数组指定位置进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Arrays.sort(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//给第0位（0开始）到第3位（不包括）排序</span></span><br><span class="line">String str = Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span></span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="comment">//输出：[1, 2, 3, 5, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="Arrays-toString"><a href="#Arrays-toString" class="headerlink" title="Arrays.toString()"></a>Arrays.toString()</h3><p><strong>输出数组</strong></p>
<p>返回String类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.print(arr);<span class="comment">//直接将数组打印输出</span></span><br><span class="line"><span class="comment">//输出：[I@7852e922 (数组的地址)</span></span><br><span class="line"></span><br><span class="line">String str = Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span></span><br><span class="line"><span class="comment">//System.out.print(str);</span></span><br><span class="line"><span class="comment">//输出：[3, 2, 1, 5, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="Arrays-equals"><a href="#Arrays-equals" class="headerlink" title="Arrays.equals()"></a>Arrays.equals()</h3><p><strong>比较数组元素是否相等</strong></p>
<pre><code>int[] arr1 = &#123;1,2,3&#125;;
int[] arr2 = &#123;1,2,3&#125;;
System.out.println(Arrays.equals(arr1,arr2));
//输出：true
//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。
</code></pre>
<h3 id="Arrays-binarySearch"><a href="#Arrays-binarySearch" class="headerlink" title="Arrays.binarySearch()"></a>Arrays.binarySearch()</h3><p><strong>二分查找法找指定元素的索引值（下标）</strong></p>
<p>数组一定是排好序的，否则会出错。找到元素，只会返回最后一个位置，若找不到如果数组中不存在该元素，则会返回 -(插入点 + 1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//输出：2 （下标索引值从0开始）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">36</span>));</span><br><span class="line"><span class="comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> []arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line"><span class="comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> []arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">40</span>));</span><br><span class="line"><span class="comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><p><strong>截取数组</strong></p>
<p>将指定数组复制成一个长度为length的新数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">3</span>);</span><br><span class="line">String str = Arrays.toString(arr1);</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="comment">//输出：[10, 20, 30] （截取arr数组的3个元素赋值给新数组arr1）</span></span><br></pre></td></tr></table></figure>

<h3 id="Arrays-copyOfRange"><a href="#Arrays-copyOfRange" class="headerlink" title="Arrays.copyOfRange()"></a>Arrays.copyOfRange()</h3><p><strong>截取数组</strong></p>
<p>将指定数组的指定范围复制到一个新的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> []arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">String str = Arrays.toString(arr1); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span></span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="comment">//输出：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span></span><br></pre></td></tr></table></figure>

<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><p>将数组转成List集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    strings[i] = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strings);</span><br><span class="line">System.out.println(list.toString());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法适用于对象型数据的数组（String、Integer…）,但此方法得到的List的长度是不可改变的，无法进行add等操作。</p>
</blockquote>
<h3 id="Arrays-stream"><a href="#Arrays-stream" class="headerlink" title="Arrays.stream()"></a>Arrays.stream()</h3><p>将数组转换成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.stream(arr).min().getAsInt());<span class="comment">//1</span></span><br><span class="line">System.out.println(Arrays.stream(arr).max().getAsInt());<span class="comment">//5</span></span><br><span class="line">System.out.println(Arrays.stream(arr).sum());<span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Arrays.stream(arr).forEach(a -&gt; aList.add(a));</span><br><span class="line">System.out.println(aList.toString());<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap与Hashtable</title>
    <url>/2022/03/08/HashMap%E4%B8%8EHashtable/</url>
    <content><![CDATA[<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>都实现Map接口，但HashMap继承AbstractMap，Hashtable继承Dictionary。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Hashtable的put和get方法加了synchronized关键字保证线程安全，而HashMap没有。</p>
<p>Hashtable的put方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//获hashcode</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//计算获取插入位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取插入位置的头结点</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//key已存在，覆盖原值</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回之前的值</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的put方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *onlyIfAbsent – if true, 不能改变存在的值</span></span><br><span class="line"><span class="comment"> *evict – if false, 处于创建模式.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//数组为空进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//要插入的位置没有节点，新建节点放入key和value</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断要插入到链表中的结点的key是否等于传入的</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果树类型（已经为转成红黑树），进入树的操作方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//？？？不是头插了？</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//转红黑树！！！TREEIFY_THRESHOLD = 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//这步？</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前面找到相同的key，覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="键和键值"><a href="#键和键值" class="headerlink" title="键和键值"></a>键和键值</h2><p>HashMap可以存储null键和null值，Hashtable不可以存储null键和null值</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>ConcurrentHashMap学习</title>
    <url>/2022/02/24/ConcurrentHashMap%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前学习ConcurrentHashMap知道原理后就一直没去看过现在的源码，今天一看，结果并没有之前看视频学的那样是两个数组组合（Segment+Entry），put的过程只是操作Node数组，这不Node不是就是以前HashMap的Entry数组吗，人都傻了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="put方法源码"><a href="#put方法源码" class="headerlink" title="put方法源码"></a>put方法源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简述流程"><a href="#简述流程" class="headerlink" title="简述流程"></a>简述流程</h1><p>1、开始依旧是获取hash</p>
<p>2、进入死循环：</p>
<p>（1）判断Node数组是否为空，空就进行初始化</p>
<p>（2）判断插入索引位置是否为空，为空就通过CAS不加锁方法进行创建</p>
<p>（3）是否正在扩容，扩容就先进行转移</p>
<p>（4）else进入锁，锁住头节点：</p>
<p>​            -非树，key存在，覆盖，不存在头插法</p>
<p>​            -树，key存在，覆盖，不存在进行树的添加操作</p>
<p>（5）addCount方法统计是否扩容</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>演变：</p>
<blockquote>
<p>HashMap出现锁问题（加锁时添加到不同位置也需要等待锁）</p>
<p>|</p>
<p>以前的ConcurrentHashMap通过segment解决加锁问题（trylock）</p>
<p>|</p>
<p>现在的ConcurrentHashMap，添加到数组相同位置通过CAS解决加锁问题</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2021/08/30/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、hexo-init-folder"><a href="#1、hexo-init-folder" class="headerlink" title="1、hexo init [folder]"></a>1、hexo init [folder]</h3><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<p>本命令相当于执行了以下几步：</p>
<blockquote>
<ol>
<li>Git clone hexo-starter和 hexo-theme-landscape 主题到当前目录或指定目录。</li>
<li>使用 Yarn 1、pnpm 或 npm包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js安装。</li>
</ol>
</blockquote>
<h3 id="2、hexo-new-layout-title"><a href="#2、hexo-new-layout-title" class="headerlink" title="2、hexo new [layout] title"></a>2、hexo new [layout] title</h3><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>



<h3 id="3、hexo-generate"><a href="#3、hexo-generate" class="headerlink" title="3、hexo generate"></a>3、hexo generate</h3><p>生成静态文件。</p>
<p>简写：hexo g</p>
<h3 id="4、hexo-server"><a href="#4、hexo-server" class="headerlink" title="4、hexo server"></a>4、hexo server</h3><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简写：hexo s</span><br></pre></td></tr></table></figure>



<h3 id="5、hexo-deploy"><a href="#5、hexo-deploy" class="headerlink" title="5、hexo deploy"></a>5、hexo deploy</h3><p>部署网站（通过配置部署到github或者其他）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简写：hexo d</span><br><span class="line"></span><br><span class="line">部署之前预先生成静态文件</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>



<h3 id="6、hexo-clean"><a href="#6、hexo-clean" class="headerlink" title="6、hexo clean"></a>6、hexo clean</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h3 id="7、hexo-publish"><a href="#7、hexo-publish" class="headerlink" title="7、hexo publish"></a>7、hexo publish</h3><p>发表草稿。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2022/02/17/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>反射允许程序在执行时借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。类加载后，堆内存的方法区产生Class类型对象，此对象包含了完整的类结构信息。</p>
<h1 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Class.forName(String name)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>类名.class</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>对象.getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型</span></span><br><span class="line"><span class="number">4.</span>Integer.TYPE</span><br></pre></td></tr></table></figure>

<p>class、interface、[]、enum、annotation、基本数据类型、void可以有Class对象（只要元素类型与维度一样，就是同一个Class）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo添加文件时增加头部默认值</title>
    <url>/2021/08/31/Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E6%97%B6%E5%A2%9E%E5%8A%A0%E5%A4%B4%E9%83%A8%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    <content><![CDATA[<p>在scaffolds下的post.md进行添加：</p>
<blockquote>
<p>title: Hexo添加文件时增加头部默认值<br>date: 1630421972000<br>tags:<br>categories:</p>
</blockquote>
<p>然后在使用hexo new “文章名”时，新建的文件夹会有上面的默认值。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux复习</title>
    <url>/2021/09/27/Linux%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>查看Linux系统位数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure>

<p>查看端口使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 端口</span><br><span class="line"></span><br><span class="line">netstat -ntpl</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf 文件</span><br></pre></td></tr></table></figure>

<p>查看Linux版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Java锁</title>
    <url>/2021/09/27/Java%E9%94%81/</url>
    <content><![CDATA[<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会来修改，所以不会上锁。</p>
<p>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</p>
<p>java中的乐观锁基本是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<blockquote>
<p>CAS：是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有现成被阻塞的情况下实现变量的同步</p>
<p>CAS原理：就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，内存值V、期望值A、更新值B，当V == A的时候将V更新为B</p>
</blockquote>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>认为写多，遇到并发写可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。</p>
<p>java中的悲观锁就是synchronized，AQS（AbstractQueuedSynchronizer）框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到才会转换为悲观锁，如RetreenLock。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，只需要等一等（自旋），等持有锁的线程释放锁即可立即获取锁，这样就避免用户线程和内核的切换消耗。</p>
<p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程 也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁 的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<blockquote>
<p><strong>优点：</strong>减少线程的阻塞，对于占用锁时间非常短的代码块来说性能大幅度提升。</p>
<p><strong>缺点：</strong>当大量锁竞争一个锁会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗。</p>
</blockquote>
<blockquote>
<p><strong>自旋锁时间阈值：</strong></p>
<p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应 性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥 有者的状态来决定，<strong>基本认为一个线程上下文切换的时间是最佳的一个时间</strong>。</p>
<p>同时 JVM 还针对当 前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋；如果有超过(CPUs/2) 个线程正在自旋，则后来线程直接阻塞；如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞；如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p>
<p><strong>开启：</strong></p>
<p>JDK 1.6 中-XX:+UseSpinning 开启； -XX:PreBlockSpin=10 为自旋次数； JDK 1.7 后，去掉此参数，由 jvm 控制</p>
</blockquote>
<h2 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h2><p>synchronized可以把任意一个非NULL的对象当作锁。属于独占式悲观锁，<strong>同时属于可重入锁</strong>。</p>
<p><strong>作用范围：</strong></p>
<p>作用于方法时，锁住的是对象的实例（this）；</p>
<p>作用于静态方法时锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen（jdk 1.8则是metaspace），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p>
<p>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将所有的这些线程存储在不同的容器中。</p>
<p><strong>核心组件：</strong></p>
<p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里； Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
<p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； </p>
<p> OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck； </p>
<p> Owner：当前已经获取到所资源的线程被称为 Owner；</p>
<p> !Owner：当前释放锁的线程；</p>
<p><strong>实现过程：</strong></p>
<ol>
<li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， Contention List 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 Entry List 中作为候选竞争线程</li>
<li>Owner 线程会在 unlock 时，将 Contention List 中的部分线程迁移到 Entry List 中，并指定 Entry List 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</li>
<li>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck， OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“竞争切换”。</li>
<li>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 Entry List 中。如果 Owner 线程被 wait 方法阻塞，则转移到 Wait Set 队列中，直到某个时刻通过 notify 或者 notifyAll 唤醒，会重新进去 Entry List 中。</li>
<li>处于 Contention List、Entry List、Wait Set 中的线程都处于阻塞状态，该阻塞是由操作系统 来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li><strong>Synchronized 是非公平锁</strong>。 Synchronized 在线程进入 Contention List 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 Contention List，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</li>
<li>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加 上 monitor enter 和 monitor exit 指令来实现的，方法加锁是通过一个标记位来判断的。</li>
<li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</li>
<li>Java 1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java 1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li>
<li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li>
<li> JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock继承接口Lock并实现了接口中定义的方法，<strong>是一种可重入锁</strong>。除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p>
<blockquote>
<p><strong>非公平锁：</strong>JVM按随机、就近原则分配锁的机制称为不公平锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁效率远远超出公平锁。</p>
<p><strong>公平锁：</strong>公平锁指的是锁的分配机制是公平的，通常对锁提出获取请求的线程会先被分配到锁。</p>
</blockquote>
<p><strong>ReentrantLock与synchronized的区别：</strong></p>
<ol>
<li>ReentrantLock通过方法lock()和unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。</li>
<li>ReentrantLock相比synchronized的优势是可中断、公平锁、多个锁。这种情况下需要使用ReentrantLock。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"> 	<span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"> 	<span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line">			<span class="comment">//1：wait 方法等待：</span></span><br><span class="line"> 			<span class="comment">//System.out.println(&quot;开始 wait&quot;);</span></span><br><span class="line"> 			condition.await();</span><br><span class="line">			<span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line">			<span class="comment">//2：signal 方法唤醒：</span></span><br><span class="line">			condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"> 			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName()+ (<span class="string">&quot; &quot;</span> + (i + <span class="number">1</span>)));</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 			e.printStackTrace();</span><br><span class="line"> 		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 			lock.unlock();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Condition 类和 Object 类锁方法的区别：</strong></p>
<ol>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效 </li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机</li>
</ol>
</blockquote>
<blockquote>
<p><strong>tryLock 和 lock 和 lockInterruptibly方法的区别：</strong></p>
<ol>
<li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit  unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false </li>
<li>lock 能获得锁就返回 true，不能的话一直等待获得锁 </li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Lock 接口的主要方法：</strong></p>
<p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁。相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </p>
<p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,  当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一 直等待, 在未获得锁之前,当前线程并不继续向下执行.  </p>
<p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程 并不持有锁, 却执行该方法, 可能导致异常的发生. </p>
<p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定， 当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将释放锁。</p>
<p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。 </p>
<p>getQueueLength()：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个 线程获得锁，此时返回的是 9</p>
<p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 </p>
<p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件 (condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法 </p>
<p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </p>
<p>hasQueuedThreads()：是否有线程等待此锁 </p>
<p>isFair()：该锁是否公平锁 </p>
<p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p>
<p>isLock()：此锁是否有任意线程占用</p>
<p>lockInterruptibly()：如果当前线程未被中断，获取锁</p>
<p>tryLock()：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </p>
<p>tryLock(long timeout,TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持， 则获取该锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Math类</title>
    <url>/2021/09/05/Math%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h3><blockquote>
<p>返回参数的绝对值</p>
</blockquote>
<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil()"></a>ceil()</h3><blockquote>
<p>返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型</p>
</blockquote>
<h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><blockquote>
<p>返回小于等于（&lt;=）给定参数的最大整数 </p>
</blockquote>
<h3 id="round"><a href="#round" class="headerlink" title="round()"></a><a href="https://www.runoob.com/java/number-round.html">round()</a></h3><blockquote>
<p>表示<strong>四舍五入</strong>，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11</p>
</blockquote>
<h3 id="rint"><a href="#rint" class="headerlink" title="rint()"></a>rint()</h3><blockquote>
<p>返回与参数最接近的整数。返回类型为double</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">100.675</span>;</span><br><span class="line">        <span class="keyword">double</span> e = <span class="number">100.500</span>;</span><br><span class="line">        <span class="keyword">double</span> f = <span class="number">100.200</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.rint(d));</span><br><span class="line">        System.out.println(Math.rint(e)); </span><br><span class="line">        System.out.println(Math.rint(f)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">101.0</span></span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">100.0</span></span><br></pre></td></tr></table></figure>

<h3 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h3><blockquote>
<p>返回两个参数中的最小值</p>
</blockquote>
<h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><blockquote>
<p>返回两个参数中的最大值</p>
</blockquote>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h3><blockquote>
<p>返回自然数底数e的参数次方（以e为底数的xx次方）</p>
</blockquote>
<h3 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h3><blockquote>
<p>返回参数的自然数底数的对数值</p>
</blockquote>
<h3 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h3><blockquote>
<p>返回第一个参数的第二个参数次方</p>
</blockquote>
<h3 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h3><blockquote>
<p>求参数的算术平方根</p>
</blockquote>
<h3 id="sin"><a href="#sin" class="headerlink" title="sin()"></a>sin()</h3><blockquote>
<p>求指定double类型参数的正弦值</p>
</blockquote>
<h3 id="cos"><a href="#cos" class="headerlink" title="cos()"></a>cos()</h3><blockquote>
<p>求指定double类型参数的余弦值</p>
</blockquote>
<h3 id="tan"><a href="#tan" class="headerlink" title="tan()"></a>tan()</h3><blockquote>
<p>求指定double类型参数的正切值</p>
</blockquote>
<h3 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h3><blockquote>
<p>返回一个随机数，随机数范围为 0.0 =&lt; Math.random &lt; 1.0</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Next主题开启更新时间</title>
    <url>/2021/08/31/Next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p><strong>直接在themes\next下的_config.yml中找到：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>

<p>把updated_at改为true就行了。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 6</title>
    <url>/2021/08/29/Redis-6/</url>
    <content><![CDATA[<h2 id="1-NoSQL数据库简介"><a href="#1-NoSQL数据库简介" class="headerlink" title="1 NoSQL数据库简介"></a>1 NoSQL数据库简介</h2><p>​        NoSQL（Not Only SQL），意为不仅仅是SQL，泛指非关系型数据库。NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大增加类数据库的扩展能力。特点：不遵循SQL标准、不支持ACID、远超SQL性能</p>
<p>​        适用场景：对数据库高并发的读写、海量数据的读写、对数据高可扩展性的</p>
<p>​        不适用场景：需要事务支持、基于Sql的结构化查询存储</p>
<h2 id="2-启动Redis（Docker方式）"><a href="#2-启动Redis（Docker方式）" class="headerlink" title="2 启动Redis（Docker方式）"></a>2 启动Redis（Docker方式）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ docker search redis <span class="comment">//检索redis镜像</span></span><br><span class="line"></span><br><span class="line">$ docker pull redis <span class="comment">//拉取redis</span></span><br><span class="line"> </span><br><span class="line">$ docker images <span class="comment">//查看本地所有镜像（需要再看看）</span></span><br><span class="line"></span><br><span class="line">$ docker run --name myRedis -d redis <span class="comment">//启动redis容器并命名,使用选项-p可以指定本地端口映射内部端口，如-p 6379:6379</span></span><br><span class="line"></span><br><span class="line">$ docker exec -it myRedis redis-cli <span class="comment">//进入访问redis</span></span><br><span class="line"></span><br><span class="line">&lt;!--上面进入redis后就可以操作了--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--其他命令--&gt;</span><br><span class="line">$ docker ps <span class="comment">//查看运行中的容器 加-a选项可以查看所有容器</span></span><br><span class="line"></span><br><span class="line">$ docker stop myRedis <span class="comment">//停止名为myRedis的容器，也可以使用id</span></span><br><span class="line"></span><br><span class="line">$ docker start myRedis <span class="comment">//启动名为myRedis的容器</span></span><br><span class="line"></span><br><span class="line">$ docker rmi redis <span class="comment">//删除redis镜像</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Redis概述"><a href="#3-Redis概述" class="headerlink" title="3 Redis概述"></a>3 Redis概述</h2><p>​        Redis：是一个开源的key-value存储系统，支持存储的value类型包括string、list、set、zset（sorted set有序集合）和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是==原子性==的。</p>
<p>​        与memcached一样，Redis数据缓存在内存中，区别是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>​        Redis是单线程+多路复用IO复用技术：</p>
<p>​        多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行</p>
<h2 id="4-Redis的Key操作命令"><a href="#4-Redis的Key操作命令" class="headerlink" title="4 Redis的Key操作命令"></a>4 Redis的Key操作命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keys * <span class="comment">//查看当前库所有key（匹配：keys *xxx)</span></span><br><span class="line">    </span><br><span class="line">exists key <span class="comment">//判断某个key是否存在</span></span><br><span class="line"></span><br><span class="line">type key <span class="comment">//查看key的类型</span></span><br><span class="line"></span><br><span class="line">del key <span class="comment">//删除指定的key数据</span></span><br><span class="line"></span><br><span class="line">unlink key <span class="comment">//根据value选择非阻塞删除,仅将keys从keyspace元数据中删			 除，真正的删除会在后续异步操作</span></span><br><span class="line"></span><br><span class="line">expire key <span class="number">10</span> <span class="comment">//10秒钟过期</span></span><br><span class="line">    </span><br><span class="line">ttl key <span class="comment">//查看还有多少秒过期，-1为永不过期，-2为已过期</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="comment">//命令切换数据库</span></span><br><span class="line"></span><br><span class="line">dbsize <span class="comment">//查看当前数据库的key的数量</span></span><br><span class="line"></span><br><span class="line">flushdb <span class="comment">//清空当前库</span></span><br><span class="line"></span><br><span class="line">flushall <span class="comment">//通杀全部库</span></span><br></pre></td></tr></table></figure>



<h2 id="5-Redis五大数据类型"><a href="#5-Redis五大数据类型" class="headerlink" title="5 Redis五大数据类型"></a>5 Redis五大数据类型</h2><h3 id="5-1-String"><a href="#5-1-String" class="headerlink" title="5.1 String"></a>5.1 String</h3><p>​        String是Redis最基本的类型，一个key对应一个value。String类型是二进制安全的，意味着Redis的String可以包含任何数据，比如jpg图片或者序列化的对象。value最多可以512M。</p>
<p>​        <strong>常用命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set key value <span class="comment">//添加</span></span><br><span class="line"></span><br><span class="line">get key <span class="comment">//获取指定key的value</span></span><br><span class="line"></span><br><span class="line">append key value <span class="comment">//将给定的value追加到原值的末尾</span></span><br><span class="line"></span><br><span class="line">setnx key value <span class="comment">//只有key不存在才设置key的值</span></span><br><span class="line"></span><br><span class="line">incr key <span class="comment">//将key中存储的数字值加1，只能对数字值操作，如果为空新增值为			 1</span></span><br><span class="line"></span><br><span class="line">decr key <span class="comment">//将key中存储的数字值减1</span></span><br><span class="line">    </span><br><span class="line">incrby/decrby key 步长 <span class="comment">//将key中存储的数字值增减，自定义步长。</span></span><br><span class="line">    </span><br><span class="line">strlen key <span class="comment">//获得值的长度</span></span><br><span class="line">    </span><br><span class="line">mset key1 value1 key2 value2... <span class="comment">//同时设置一个或多个key-value对</span></span><br><span class="line"></span><br><span class="line">mget key1 key2... <span class="comment">//同时获取多个value</span></span><br><span class="line"></span><br><span class="line">msetnx key1 value1 key2 value2... <span class="comment">//同时设置一个或多个key-value对，当且仅当所有给定key都不存在</span></span><br><span class="line"></span><br><span class="line">getrange key 起始位置 结束位置 <span class="comment">//获取值的范围，类似java中的								  substring</span></span><br><span class="line">setrange key 起始位置 value <span class="comment">//用value从key中所存储的字符串值指定								位置开始插入</span></span><br><span class="line">    </span><br><span class="line">setex key 过期时间 value <span class="comment">//设置键值的同时设置过期时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        <strong>数据结构：</strong></p>
<p>​        String的数据结构为简单动态字符串（Simple Dynamic String，SDS），是可以修改的字符串，内部结构实现上类似于java的ArrayList，采用预分配冗余空间方式来减少内存的频繁分配。</p>
<h3 id="5-2-List"><a href="#5-2-List" class="headerlink" title="5.2 List"></a>5.2 List</h3><p>​        Redis的列表List是简单的字符串列表，安照插入顺序，可以添加一个元素到列表的头部或者尾部。它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间节点性能会较差。</p>
<p>​        <strong>常用命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lpush/rpush key value1 value2 value3… <span class="comment">//从左边/右边插入一个或多个值。</span></span><br><span class="line"></span><br><span class="line">lpop/rpop key <span class="comment">//从左边/右边弹出一个值，所有值没了键也消失。</span></span><br><span class="line"></span><br><span class="line">rpoplpush key1 key2 <span class="comment">//从key1列表右边弹出一个值，差到key2列表左边。</span></span><br><span class="line"></span><br><span class="line">lrange key stat stop <span class="comment">//按照索引下标活动元素，从左到右（lrang key 0 -1 表示获取所有）</span></span><br><span class="line"></span><br><span class="line">lindex key index <span class="comment">//按照索引下标获得元素（从左到右）</span></span><br><span class="line"></span><br><span class="line">llen key <span class="comment">//获得列表长度</span></span><br><span class="line"></span><br><span class="line">linsert key before value newvalue <span class="comment">//在value之前插入值</span></span><br><span class="line"></span><br><span class="line">lrem key n value <span class="comment">//从左边开始删除n个value</span></span><br><span class="line"></span><br><span class="line">lset key index value <span class="comment">//将列表key下标为index的值替换成value</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>数据结构：</strong></p>
<p>​        List的数据结构为快速链表quicklist，首先在列表元素较少的情况下回使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧凑着挨在一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。</p>
<p>​        Redis将链表和ziplist结合起来组成类quicklist，也就是将多个ziplist使用双向指针串起来，这样既满足类快速插入删除的性能，又不会出现太大的空间冗余。</p>
<h3 id="5-3-Set"><a href="#5-3-Set" class="headerlink" title="5.3 Set"></a>5.3 Set</h3><p>​        Redis中的set对外提供的功能与list类似，特殊之处在于set是可以自动排重的，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供类判断某个成员是否在一个set集合内的重要接口。</p>
<p>​        Redis的set是string类型的无需集合，底层是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)</p>
<p>​        <strong>常用命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sadd key value1 value2 … <span class="comment">//将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略。</span></span><br><span class="line"></span><br><span class="line">smembers key <span class="comment">//取出该集合的所有值</span></span><br><span class="line"></span><br><span class="line">sismember key value <span class="comment">//判断集合key是否为含有该value值，有返回1，没有返回0</span></span><br><span class="line"></span><br><span class="line">scard key <span class="comment">//返回该集合的元素个数</span></span><br><span class="line"></span><br><span class="line">srem key value1 value2 <span class="comment">//删除集合中的某个元素</span></span><br><span class="line"></span><br><span class="line">spop key <span class="comment">//随机弹出一个值</span></span><br><span class="line"></span><br><span class="line">srandmember key n <span class="comment">//随机从集合中取出n个值，不会从集合中删除</span></span><br><span class="line"></span><br><span class="line">smove soure destination value <span class="comment">//把集合中一个值从一个集合移动到另一个集合</span></span><br><span class="line"></span><br><span class="line">sinter key1 key2 <span class="comment">//返回两个集合的交集元素</span></span><br><span class="line"></span><br><span class="line">sunion key1 key2 <span class="comment">//返回两个集合的并集元素</span></span><br><span class="line"></span><br><span class="line">sdiff key1 key2 <span class="comment">//返回两个几个的差集元素（key1中的，不包含key2中的）</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>数据结构：</strong></p>
<p>​        set的数据结构是dict字典，字典是用hash表实现的。Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样。</p>
<h3 id="5-4-Hash"><a href="#5-4-Hash" class="headerlink" title="5.4 Hash"></a>5.4 Hash</h3><p>​        Redis中hash是一个键值对集合，是一个field和value的映射表，hash特别适合用于存储对象。</p>
<p>​        <strong>常用命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hset key field value <span class="comment">//给key集合中的field键赋值value</span></span><br><span class="line"></span><br><span class="line">hget key field <span class="comment">//从key集合中取出field对应的value</span></span><br><span class="line"></span><br><span class="line">hmset key field1 value1 field2 value1… <span class="comment">//批量设置hash的值</span></span><br><span class="line"></span><br><span class="line">hexists key field <span class="comment">//查看key对应的field是否存在</span></span><br><span class="line"></span><br><span class="line">hkeys key <span class="comment">//列出该hash集合的所有field</span></span><br><span class="line"></span><br><span class="line">hvals key <span class="comment">//列出该hash集合的所有value</span></span><br><span class="line"></span><br><span class="line">hincrby key field increment <span class="comment">//为哈希表key中的域field的值加上增量</span></span><br><span class="line"></span><br><span class="line">hsetnx key field value <span class="comment">//将哈希表key中的域field的值设置为value，当且仅当域field不存在</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>数据结构：</strong></p>
<p>​        Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="5-5-Zset（Sorted-set）"><a href="#5-5-Zset（Sorted-set）" class="headerlink" title="5.5 Zset（Sorted set）"></a>5.5 Zset（Sorted set）</h3><p>​        Redis有序集合zset与普通集合set非常相似，没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分（score），这个<strong>评分被用来按照从最低分到最高分的方式排序</strong>集合中的成员。集合的成员是唯一的，但是评分可以是重复的。也可以根据评分或者次序来获取一个范围的元素。</p>
<p>​        <strong>常用命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2… <span class="comment">//将一个或者多个member元素及其score值加入到有序集key当中。</span></span><br><span class="line"></span><br><span class="line">zrange key start stop [WITHSCORES] <span class="comment">//返回有序集key中，下标在start和stop之间的元素，带WITHSCORES 可以让分数一起和值返回到结果集。0到-1返回所有</span></span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [limit offset count] <span class="comment">//返回有序集key中所有score值介于min和max之间（包括等于min和max）的成员，有序集成员按score值递增次序排序</span></span><br><span class="line"></span><br><span class="line">zrevrangebyscore key min max [WITHSCORES] [limit offset count] <span class="comment">//同上，按递减排序</span></span><br><span class="line"></span><br><span class="line">zincrby key increment value <span class="comment">//为元素的score加上增量</span></span><br><span class="line"></span><br><span class="line">zcount key min max <span class="comment">//统计该集合，分数区间内的元素个数</span></span><br><span class="line"></span><br><span class="line">zrank key value <span class="comment">//返回该值在集合中的排名，从0开始</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>数据结构：</strong></p>
<p>​        zset是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String，Double&gt;，可以给每一个元素value赋予一个权重score。另外又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素列表。</p>
<p>​        zet底层使用了两个数据结构：</p>
<blockquote>
<p>​        hash，hash的作业就是关联元素value和权重，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>​        跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
</blockquote>
<h2 id="6-发布与订阅"><a href="#6-发布与订阅" class="headerlink" title="6 发布与订阅"></a>6 发布与订阅</h2><p>​        Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。Redis客户端可以订阅任意数量的频道。</p>
<p>​        <strong>命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subscribe channel1 <span class="comment">//打开一个客户端订阅</span></span><br><span class="line">publish channel1 hello <span class="comment">//往channel1中发送消息hello，这样订阅了channel1的客户端都会收到hello</span></span><br></pre></td></tr></table></figure>

<h2 id="7-Redis新数据类型"><a href="#7-Redis新数据类型" class="headerlink" title="7 Redis新数据类型"></a>7 Redis新数据类型</h2><h3 id="7-1-Bitmaps"><a href="#7-1-Bitmaps" class="headerlink" title="7.1 Bitmaps"></a>7.1 Bitmaps</h3><p>​        Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<blockquote>
<p>​        Bitmaps本身不是一种数据类型，实际它就是字符串（key-value），但是可以对字符串的位进行操作。</p>
<p>​        Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方式不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫偏移量。</p>
</blockquote>
<p>​        <strong>命令：</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务</title>
    <url>/2021/10/09/Spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="两种管理方式"><a href="#两种管理方式" class="headerlink" title="两种管理方式"></a>两种管理方式</h2><p>spring中事务主要有两种管理方式，编程式事务管理和声明式事务管理。</p>
<p>编程式事务是使用TransactionTemplate或者Platform TransactionManager来进行事务实现</p>
<p>声明式事务是建立在Spring Aop之上，使用aop对目标方法进行拦截，在目标方法开始之前创建或加入一个事务，在执行完目标方法之后根据执行的情况提交事务或者回滚事务。</p>
<h2 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h2><p>事务传播机制是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何去执行，例如method1方法添加了事务，去调用method2事务方法，那么method2是继续在method1的事务中执行还是新开一个事务执行，这就需要method2的事务传播机制来决定。</p>
<p><strong>7个事务传播机制：</strong></p>
<blockquote>
<p>Propagation.REQUIRED：如果有事务就加入事务，没有就创建一个(默认)</p>
<p>Propagation.SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>Propagation.MANDATORY：使用当前事务，如果当前没有事务，就抛出异常。</p>
<p>Propagation.REQUIRES_NEW：新建事务， 如果当前存在事务，就把事务挂起。</p>
<p>Propagation.NOT_SUPPORTED：以非事务的方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>Propagation.NEVER：以非事务方式执行，如果当前存在事务，就抛出异常。</p>
<p>Propagation.NESTED：如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则创建一个。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<blockquote>
<p>@Transactional (propagation=Propagation.NESTED)</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>String常用方法源码学习</title>
    <url>/2022/01/07/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="String源码学习"><a href="#String源码学习" class="headerlink" title="String源码学习"></a>String源码学习</h1><h2 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coder() == str.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.indexOf(value, str.value)</span><br><span class="line">                          : StringUTF16.indexOf(value, str.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coder() == LATIN1) &#123;  <span class="comment">// str.coder == UTF16</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUTF16.indexOfLatin1(value, str.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Latin1："><a href="#Latin1：" class="headerlink" title="Latin1："></a>Latin1：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOf(value, value.length, str, str.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">int</span> valueCount, <span class="keyword">byte</span>[] str, <span class="keyword">int</span> strCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> first = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = (valueCount - strCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个相同的字符</span></span><br><span class="line">        <span class="keyword">if</span> (value[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; value[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当找到第一个相同字符后，逐个比较后面的字符</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j + strCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt; end &amp;&amp; value[j] == str[k]; j++, k++);</span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">// Found whole string.</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abbcd</span><br><span class="line">bc</span><br><span class="line"></span><br><span class="line">第一轮：</span><br><span class="line">max=3</span><br><span class="line">i=1</span><br><span class="line">j=2</span><br><span class="line">end=3</span><br><span class="line">value[2]=b</span><br><span class="line">str[1]=c</span><br><span class="line"></span><br><span class="line">第二轮：</span><br><span class="line">max=3</span><br><span class="line">i=2</span><br><span class="line">j=3</span><br><span class="line">end=4</span><br><span class="line">value[3]=c</span><br><span class="line">str[1]=c</span><br><span class="line">j++</span><br><span class="line">j=4</span><br><span class="line">j==end</span><br><span class="line">return 2</span><br></pre></td></tr></table></figure>



<h3 id="UTF16："><a href="#UTF16：" class="headerlink" title="UTF16："></a>UTF16：</h3><p>与StringLatin1类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; str.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOfUnsafe(value, length(value), str, length(str), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfUnsafe</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">int</span> valueCount, <span class="keyword">byte</span>[] str, <span class="keyword">int</span> strCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> fromIndex &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assert</span> strCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">assert</span> strCount &lt;= length(str);</span><br><span class="line">    <span class="keyword">assert</span> valueCount &gt;= strCount;</span><br><span class="line">    <span class="keyword">char</span> first = getChar(str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> max = (valueCount - strCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">// Look for first character.</span></span><br><span class="line">        <span class="keyword">if</span> (getChar(value, i) != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; getChar(value, i) != first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Found first character, now look at the rest of value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j + strCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt; end &amp;&amp; getChar(value, j) == getChar(str, k); j++, k++);</span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">// Found whole string.</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="compareTo方法"><a href="#compareTo方法" class="headerlink" title="compareTo方法"></a>compareTo方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> v1[] = value;</span><br><span class="line">    <span class="keyword">byte</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">if</span> (coder() == anotherString.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">                          : StringUTF16.compareTo(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">                      : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Latin1：-1"><a href="#Latin1：-1" class="headerlink" title="Latin1："></a>Latin1：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = other.length;</span><br><span class="line">    <span class="keyword">return</span> compareTo(value, other, len1, len2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lim; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[k] != other[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getChar(value, k) - getChar(other, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="UTF16：-1"><a href="#UTF16：-1" class="headerlink" title="UTF16："></a>UTF16：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = length(value);</span><br><span class="line">    <span class="keyword">int</span> len2 = length(other);</span><br><span class="line">    <span class="keyword">return</span> compareValues(value, other, len1, len2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareValues</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lim; k++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = getChar(value, k);</span><br><span class="line">        <span class="keyword">char</span> c2 = getChar(other, k);</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2021/08/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><blockquote>
<p># 在当前目录新建一个Git代码库</p>
<p>$ git init</p>
<p># 新建一个目录，将其初始化为Git代码库</p>
<p>$ git init [project-name]</p>
<p># 下载一个项目和它的整个代码历史</p>
<p>$ git clone [url]</p>
<p>如：git clone <a href="https://github.com/paidaxingaa/paidaxinga.git">https://github.com/paidaxingaa/paidaxinga.git</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p># 显示当前的Git配置</p>
<p>$ git config –list</p>
<p># 编辑Git配置文件</p>
<p>$ git config -e [–global]</p>
<p># 设置提交代码时的用户信息</p>
<p>$ git config [–global] user.name “[name]”</p>
<p>$ git config [–global] user.email “[email address]”</p>
</blockquote>
<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><blockquote>
<p># 添加指定文件到暂存区</p>
<p>$ git add [file1] [file2] …</p>
<p># 添加指定目录到暂存区，包括子目录</p>
<p>$ git add [dir]</p>
<p># 添加当前目录的所有文件到暂存区</p>
<p>$ git add .</p>
<p># 删除工作区文件，并且将这次删除放入暂存区</p>
<p>$ git rm [file1] [file2] …</p>
<p># 改名文件，并且将这个改名放入暂存区</p>
<p>$ git mv [file-original] [file-renamed]</p>
</blockquote>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><blockquote>
<p># 提交暂存区到仓库区</p>
<p>$ git commit -m [message]</p>
<p>如：git commit -m ‘个人博客’</p>
<p># 提交暂存区的指定文件到仓库区</p>
<p>$ git commit [file1] [file2] … -m [message]</p>
<p># 提交工作区自上次commit之后的变化，直接到仓库区</p>
<p>$ git commit -a</p>
</blockquote>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote>
<p># 列出所有本地分支</p>
<p>$ git branch</p>
<p># 列出所有远程分支</p>
<p>$ git branch -r</p>
<p># 新建一个分支，但依然停留在当前分支</p>
<p>$ git branch [branch-name]</p>
<p># 切换到指定分支，并更新工作区</p>
<p>$ git checkout [branch-name]</p>
<p># 删除分支</p>
<p>$ git branch -d [branch-name]</p>
<p># 删除远程分支</p>
<p>$ git push origin –delete [branch-name]</p>
</blockquote>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><blockquote>
<p># 显示有变更的文件</p>
<p>$ git status</p>
<p># 显示当前分支的版本历史</p>
<p>$ git log</p>
</blockquote>
<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><blockquote>
<p># 下载远程仓库的所有变动，如果有冲突需要手动处理</p>
<p>$ git fetch [remote]</p>
<p>如：git fetch origin main</p>
<p># 显示所有远程仓库</p>
<p>$ git remote -v</p>
<p># 显示某个远程仓库的信息</p>
<p>$ git remote show [remote]</p>
<p># 增加一个新的远程仓库，并命名</p>
<p>$ git remote add [shortname] [url]</p>
<p>#删除远程仓库</p>
<p>git remote rm origin</p>
<p>更改仓库指向</p>
<p>$ git remote set-url origin <a href="https://github.com/paidaxingaa/paidaxinga.git">https://github.com/paidaxingaa/paidaxinga.git</a></p>
<p># 上传本地指定分支到远程仓库</p>
<p>$ git push [remote] [branch]</p>
<p>如：git push origin main</p>
<p># 强行推送当前分支到远程仓库，即使有冲突</p>
<p>$ git push -f [remote] [branch]</p>
<p># 推送所有分支到远程仓库</p>
<p>$ git push [remote] –all</p>
<p>#从远程仓库获取代码并合并本地的版本</p>
<p>$ git pull  [remote] [branch]</p>
<p>#多人开发中有多个merge commit，如果不加rebase参数则有多个历史提交线，而它的作用是每次提交都将分叉提交线中的一条捡选出在另一条提交线上提交，最后形成一条单元的提交线</p>
<p>$ git pull –rebase [remote] [branch]</p>
</blockquote>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><blockquote>
<p># 恢复暂存区的指定文件到工作区</p>
<p>$ git checkout [file]</p>
<p># 恢复某个commit的指定文件到暂存区和工作区</p>
<p>$ git checkout [commit] [file]</p>
<p># 恢复暂存区的所有文件到工作区</p>
<p>$ git reset [file]</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2021/08/31/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        synchronized关键字解决线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><p>​        <strong>原子性：</strong>一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</p>
<p>​        <strong>可见性：</strong>当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行lock、unlock原子操作，保证可见性。</p>
<p>​        <strong>有序性：</strong>程序的执行顺序会按照代码的先后顺序执行。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>​        <strong>修饰代码块：</strong>即同步代码块，作用的对象是调用这个代码块的对象。即指定加锁对象，对给定的对象加锁，进入同步代码块之前要获得给定的对象的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SynchronizedDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同步代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>修饰实例方法：</strong>即同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象。进入同步方法之前要获取当前对象实例的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SynchronizedDemo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同步方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>修饰静态方法：</strong>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象。如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象。因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SynchronizedDemo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同步静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。synchronized关键字加到实例方法是给对象实例上锁。尽量不要使用synchronized(String a)，因为JVM中字符串常量池具有缓存功能。</p>
</blockquote>
<p>​        <strong>双重校验锁实现对象单例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized关键字可以实现什么类型的锁"><a href="#synchronized关键字可以实现什么类型的锁" class="headerlink" title="synchronized关键字可以实现什么类型的锁"></a>synchronized关键字可以实现什么类型的锁</h2><p>​        <strong>悲观锁：</strong>synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</p>
<p>​        <strong>非公平锁：</strong>synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</p>
<p>​        <strong>可重入锁：</strong>synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</p>
<p>​        <strong>独占锁或排他锁：</strong>synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</p>
<h2 id="synchronized关键字底层优化"><a href="#synchronized关键字底层优化" class="headerlink" title="synchronized关键字底层优化"></a>synchronized关键字底层优化</h2><p>​        JDK1.6后对锁的实现引入了大量优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁优化等来减少操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁，它们会随着竞争的激烈而逐渐升级。</p>
<h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><p>​        （1）<strong>两者都是可重入锁：</strong></p>
<p>​        可重入锁的概念是，自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没释放，当其再次想要获取这个对象的锁的时候还是可以获取的。</p>
<p>​        （2）<strong>synchronized依赖于JVM而ReentrantLock依赖于API：</strong></p>
<p>​        synchronized是依赖于JVM实现的，而ReentrantLock是JDK层面实现的，需要lock()和unlock()方法配合try/finally语句块来完成。</p>
<p>​        （3）<strong>ReentrantLock比synchronized增加了一些高级功能：</strong></p>
<p>​        主要有三点：等待可中断、可实现公平锁、可实现选择性通知（锁可以绑定多个条件）</p>
<blockquote>
<ol>
<li>​        ReentrantLock提供了一种能够中断等待锁的线程机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>​        ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓公平锁是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</li>
<li>​        synchronized关键字可以与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock要借助Condition接口与newCondition()方法。Condition有很好的灵活性，比如可以实现多路通知功能也就是一个Lock对象可以创建多个Condition实例(即对象监视器)，线程对象可以注册在指定的Condition中，从而获得有选择性的进行线程通知。<strong>在使用notify()/notifyAll()方法进行通知时，被通知的线程是由JVM选择的，用ReentrantLock类结合Condition实例可以实现选择性通知。</strong>而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有线程都注册在它身上，如果执行notifyAll()方法的话就会通知所有处于等待的线程或造成很大的效率问题。<strong>而Condition实例的signalAll()方法，只会唤醒注册Condition实例中的所有线程。</strong></li>
</ol>
</blockquote>
<p>​        （4）<strong>性能不再是选择标准</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>transient关键字</title>
    <url>/2022/03/08/transient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>将对象写入到IO流中</p>
<p>序列化主要有两种用途：</p>
<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列。</li>
</ul>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>从IO流中恢复对象</p>
<h1 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h1><p>一个类实现了Serializable接口，这个类的所有属性和方法都会自动序列化。</p>
<p>在开发过程中,当要求对象被序列化时（写入字节序列到目标文件）时，有些属性需要序列化，而有些属性不需要被序列化。</p>
<p>不需要被序列化的属性加上transient关键字，这个属性的生命周期仅存于调用者的内存中而不会写到磁盘里持久化</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote>
<p>被transient修饰的变量不再能被序列化，不再是对象持久化的一部分，该变量内容在序列化后无法获得访问</p>
</blockquote>
<blockquote>
<p>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>删除远程仓库的文件夹</title>
    <url>/2022/03/05/%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>删除远程仓库文件夹</p>
<blockquote>
<p>git rm -r –cached 文件夹名</p>
<p>git commit -m “2022/03/05”</p>
<p>git push -u origin “master”</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/09/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方法。</p>
<p>​        这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。该类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>​        主要解决一个全局使用的类频繁地创建与销毁。通过判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>​        <strong>线程不安全：</strong>这种方式是最基本的实现方式，这种实现不支持多线程，没有加锁synchronized，严格意义上不上算单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        	instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        <strong>线程安全：</strong>这种方式具备很好的lazy loading，能够在多线程中很好的工作，但是效率很低，因为大多情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。确定：必须加锁synchronized才能保证单例，会影响效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        	instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>​        这种方式比较常用，是线程安全的。，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时初始化，浪费内存。它基于ClassLoader机制避免了多线程的同步问题，不过instance在类装载时就实例化了。虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双检验-双重校验锁"><a href="#双检验-双重校验锁" class="headerlink" title="双检验/双重校验锁"></a>双检验/双重校验锁</h2><p>​        DCL，double-checked locking，是lazy loading，也线程安全的。这种方式采用双锁机制，安全且在多线程下能保持高性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    	<span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h2><p>​        是lazy loading，也线程安全的。</p>
<p>​        这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<p>​        这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第饿汉式不同的是：饿汉式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比饿汉式就显得很合理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>​        这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p>
<p>​        这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2021/09/03/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        volatile是一个轻量级的synchronized，一般作用于变量，在多处理器开发的过程中保证了内存的可见性。相比于synchronized关键字，volatile关键字的执行成本更低，效率更高。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>​        <strong>可见性：</strong>volatile可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读到共享变量被修改后的值。</p>
<p>​        <strong>有序性：</strong>volatile会通过禁止指令重排序进而保证有序性。</p>
<p>​        （volatile只能保证可见性和有序性，但可以保证64位的long型和double型变量的原子性。）</p>
<h2 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h2><p>​        volatile可以保证内存可见的关键是volatile的读写实现了缓存一致性，主要内容为：</p>
<blockquote>
<p>1、每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。</p>
<p>2、当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</p>
</blockquote>
<h2 id="有序性原理"><a href="#有序性原理" class="headerlink" title="有序性原理"></a>有序性原理</h2><p>​        为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。</p>
<p>​        内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p>
<h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><ol>
<li>volatile主要保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。synchronized主要是解决多个线程访问资源的同步性。</li>
<li>volatile作用于变量，synchronized作用于代码块或方法。</li>
<li>volatile仅可以保证数据的可见性，但不能保证数据的原子性。synchronized可以保证数据的可见性和原子性。</li>
<li>volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配</title>
    <url>/2022/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/8 20:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ts = <span class="string">&quot;abababc&quot;</span>;</span><br><span class="line">        String ps = <span class="string">&quot;ababc&quot;</span>;</span><br><span class="line">        System.out.println(noKMP(ts,ps));</span><br><span class="line">        System.out.println(KMP(ts,ps));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">noKMP</span><span class="params">(String ts,String ps)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = ts.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p = ps.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//主串的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//子串的位置</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i] == p[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == p.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//KMP</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String ts,String ps)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = ts.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p = ps.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//主串的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//子串的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(ps);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || t[i] == p[j])&#123;<span class="comment">//j = -1,要移动i，同时j归0</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == p.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String ps)&#123;</span><br><span class="line">        <span class="keyword">char</span>[] p = ps.toCharArray();</span><br><span class="line">        <span class="comment">//记录在j位置时j前子串的最大重复子串，</span></span><br><span class="line">        <span class="comment">//如abdabab，6前为abdaba，</span></span><br><span class="line">        <span class="comment">// 前缀集&#123;a,ab,abd,abda,abdab&#125;,后缀集&#123;a,ba,aba,daba,bdaba&#125;</span></span><br><span class="line">        <span class="comment">//只有a重复子串最大</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">        <span class="comment">//0处前面没有子串</span></span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这段没看到只能举例说服自己：</span></span><br><span class="line"><span class="comment">         * ps = “ababc”</span></span><br><span class="line"><span class="comment">         * next[0] = -1,j = 0,k = -1;</span></span><br><span class="line"><span class="comment">         * next[1] = 0,j = 1,k = 0;</span></span><br><span class="line"><span class="comment">         * 此时p[j] != p[k];</span></span><br><span class="line"><span class="comment">         * k = next[k] = next[0] = -1;j = 1,k = -1;</span></span><br><span class="line"><span class="comment">         * next[2] = 0,j = 2,k = 0;</span></span><br><span class="line"><span class="comment">         * p[j] == p[k],next[3] = 1,j = 3,k = 1;</span></span><br><span class="line"><span class="comment">         * p[j] == p[k],next[4] = 2,j = 4,k = 2;</span></span><br><span class="line"><span class="comment">         * 退出循环</span></span><br><span class="line"><span class="comment">         * next = [-1,0,0,1,2]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 回看：k = next[k];的赋值操作是</span></span><br><span class="line"><span class="comment">         * 将k回退到匹配到的最大重复子串中，</span></span><br><span class="line"><span class="comment">         * 继续寻找当前可能的最大重复子串；</span></span><br><span class="line"><span class="comment">         * 类似于回到最开始的问题，要移动到的k的位置(这里博客大佬画得太妙了）</span></span><br><span class="line"><span class="comment">         * ps = &quot;abdabab&quot;</span></span><br><span class="line"><span class="comment">         * next[0] = -1,j = 0,k = -1;</span></span><br><span class="line"><span class="comment">         * next[1] = 0,j = 1,k = 0;</span></span><br><span class="line"><span class="comment">         * p[j] != p[k];</span></span><br><span class="line"><span class="comment">         * k = next[k] = next[0] = -1;j = 1,k = -1;</span></span><br><span class="line"><span class="comment">         * next[2] = 0,j = 2,k = 0;</span></span><br><span class="line"><span class="comment">         * p[j] != p[k];</span></span><br><span class="line"><span class="comment">         * k = next[k] = next[0] = -1;j = 2,k = -1;</span></span><br><span class="line"><span class="comment">         * next[3] = 0,j = 3,k = 0;</span></span><br><span class="line"><span class="comment">         * next[4] = 1,j = 4,k = 1;此时到abdab最后的b,b前面有a重复</span></span><br><span class="line"><span class="comment">         * next[5] = 2,j = 5,k = 2;此时到abdaba最后的a,a前面有ab重复</span></span><br><span class="line"><span class="comment">         * p[j] != p[k];  &lt;a != d&gt;</span></span><br><span class="line"><span class="comment">         * k = next[k] = next[2] = 0;j = 5,k = 0;回退到第一个a处了</span></span><br><span class="line"><span class="comment">         * next[6] = 1,j = 6,k = 1;</span></span><br><span class="line"><span class="comment">         * 退出循环</span></span><br><span class="line"><span class="comment">         * next = [-1,0,0,0,1,2,1]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>学习源自大佬的博客：<a href="https://www.cnblogs.com/dusf/p/kmp.html">地址</a></p>
<p>体会：从看推导到看实现，觉得不可思议，尤其是通过找 j 移动的位置推导出找最大重复子串的过程，太妙了！后面在看求next数组的过程推导有点懵了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/09/03/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>​        意图：定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正方形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>创建工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">&quot;Circle&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">&quot;Rectangle&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">&quot;Square&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>使用工厂类，通过传递类型信息来获取实体类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ShapeFactory factory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        </span><br><span class="line">        Shape shape1 = factory.getShape(<span class="string">&quot;circle&quot;</span>);</span><br><span class="line">        shape1.draw();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Shape shape2 = factory.getShape(<span class="string">&quot;rectangle&quot;</span>);</span><br><span class="line">        shape2.draw();</span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line">        Shape shape3 = factory.getShape(<span class="string">&quot;square&quot;</span>);</span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">圆形</span><br><span class="line">矩形</span><br><span class="line">正方形</span><br></pre></td></tr></table></figure>

<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>​        工厂工厂模式就是通过工厂类去创建对象，而不是直接创建对象，好处就是只需要对一个工厂类进行操作并传递相关信息就能创建工厂类中的各种对象。</p>
<p>​        通俗地说，“哎，那个那个，我要造一台奔驰车”，“好的老板，车工厂在造了”，“哎，那个那个，我要造一台宝马车”，“好的，在造了”。车不需要知道怎么造，我指定了，到时就提车，车也有了相应的功能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/09/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        原型模式（ProtoType Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方式。</p>
<p>​        这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一次请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>​        意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建一个实现类Cloneable接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line">   <span class="keyword">protected</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object clone = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建扩展了抽象类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">&quot;矩形&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">&quot;正方形&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;正方形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      = <span class="keyword">new</span> Hashtable&lt;String, Shape&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取到指定的shape</span></span><br><span class="line">      Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">       <span class="comment">//返回其克隆对象</span></span><br><span class="line">      <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">   <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">   <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"> </span><br><span class="line">      Square square = <span class="keyword">new</span> Square();</span><br><span class="line">      square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"> </span><br><span class="line">      Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      rectangle.setId(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"> </span><br><span class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;形状 : &quot;</span> + clonedShape.getType());        </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;形状 : &quot;</span> + clonedShape2.getType());        </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;形状 : &quot;</span> + clonedShape3.getType());        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">形状 : 圆形</span><br><span class="line">形状 : 正方形</span><br><span class="line">形状 : 矩形</span><br></pre></td></tr></table></figure>

<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>​        原型模式最大的特征就是克隆，当需要获取指定的对象时，若直接重新去创建对于复杂的对象会涉及到很多原对象属性的获取，因此可以通过clone返回。</p>
<p>​        当然原型模式的整体上使用也类似于工厂模式，通过传递信息去生产对象，而不是自己去创建。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2021/09/06/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方式。</p>
<p>​        一个Builder类会一步一步构造最终的对象，该Builder类是独立于其他对象的。</p>
<p>​        意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建表示食物条目和食物包装的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创包装接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;纸盒&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;瓶装&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>创建实现Item接口的抽象类，并提供了默认的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>创建继承Burger和ColdDrink的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;蔬菜汉堡&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;鸡肉汉堡&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;可口可乐&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;百事可乐&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();    </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         cost += item.price();</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         System.out.print(<span class="string">&quot;菜单项 : &quot;</span>+item.name());</span><br><span class="line">         System.out.print(<span class="string">&quot;, 包装 : &quot;</span>+item.packing().pack());</span><br><span class="line">         System.out.println(<span class="string">&quot;, 价格 : &quot;</span>+item.price());</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h3><p>创建一个MealBuilder类，实际的builder类负责创建Meal对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//菜单一</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;   </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//菜单二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"> </span><br><span class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">      System.out.println(<span class="string">&quot;素食汉堡菜单&quot;</span>);</span><br><span class="line">      vegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">&quot;总价格: &quot;</span> +vegMeal.getCost());</span><br><span class="line"> </span><br><span class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">      System.out.println(<span class="string">&quot;\n\n非素食汉堡菜单&quot;</span>);</span><br><span class="line">      nonVegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">&quot;总价格: &quot;</span> +nonVegMeal.getCost());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">素食汉堡菜单</span><br><span class="line">菜单项 : 蔬菜汉堡, 包装 : 纸盒, 价格 : 25.0</span><br><span class="line">菜单项 : 可口可乐, 包装 : 瓶装, 价格 : 30.0</span><br><span class="line">总价格: 55.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">非素食汉堡菜单</span><br><span class="line">菜单项 : 鸡肉汉堡, 包装 : 纸盒, 价格 : 50.5</span><br><span class="line">菜单项 : 百事可乐, 包装 : 瓶装, 价格 : 35.0</span><br><span class="line">总价格: 85.5</span><br></pre></td></tr></table></figure>

<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>​        建造者模式通过一个Builder类去创建一个具体的的对象，再由这个对象去构建自己的内容。比如上面的例子就是，通过MealBuilder去创建菜单，然后在菜单类里，菜单去构建菜单项并提供相应获得菜单项的方法，而菜单项又包含了一个个具体的信息。</p>
<p>​        与工厂模式、抽象工厂模式不同的是，建造者模式并没有通过传递信息去指定相关的类得到想要的东西，而是交由Builder类去一步一步构建出来。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>常用4大并发工具类</title>
    <url>/2021/10/22/%E5%B8%B8%E7%94%A84%E5%A4%A7%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch又称闭锁，类似加强版的Join，是让一组线程等待其他线程完成工作以后才执行。例如：在启动框架服务的时候，我们的主线程需要在环境线程初始化完成之后才能启动，这时候我们就可以实现使用CountDownLatch来完成。</p>
<blockquote>
<p><strong>方法：</strong></p>
<p>CountDownLatch(int)：初始化构造方法，需要传入一个int类型的参数，当执行扣减后等待的线程被唤醒。</p>
<p>await()：等待方法</p>
<p>await(long，TimeUnit)：等待方法，参数传入是超时重载</p>
<p>countDown(int)：每执行一次，计数器减一，即初始化传入的数字，减一代表着一个线程完成了任务。</p>
<p>getCount()：获取当前计数器值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/25 10:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;-&quot;</span>+<span class="string">&quot;初始化线程--准备初始化&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;-&quot;</span>+<span class="string">&quot;初始化线程--开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getId()+<span class="string">&quot;-&quot;</span>+<span class="string">&quot;业务线程--开始工作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第一次暂停&quot;</span>);</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;-&quot;</span>+<span class="string">&quot;1单独线程准备初始化工作&quot;</span>);</span><br><span class="line">                <span class="comment">//减扣一次</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;第二次暂停&quot;</span>);</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;-&quot;</span>+<span class="string">&quot;2单独线程准备初始化工作&quot;</span>);</span><br><span class="line">                <span class="comment">//减扣一次</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//启动业务线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyThread()).start();</span><br><span class="line">        <span class="comment">//启动初始化线程,4个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> InitTread()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主线程main进入等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程工作。。。&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">第一次暂停</span><br><span class="line"><span class="number">17</span>-初始化线程--准备初始化</span><br><span class="line"><span class="number">15</span>-初始化线程--准备初始化</span><br><span class="line"><span class="number">15</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">15</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">13</span>-<span class="number">1</span>单独线程准备初始化工作</span><br><span class="line">第二次暂停</span><br><span class="line"><span class="number">18</span>-初始化线程--准备初始化</span><br><span class="line"><span class="number">18</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">18</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">17</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">17</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">13</span>-<span class="number">2</span>单独线程准备初始化工作</span><br><span class="line"><span class="number">16</span>-初始化线程--准备初始化</span><br><span class="line"><span class="number">16</span>-初始化线程--开始工作</span><br><span class="line"><span class="number">16</span>-初始化线程--开始工作</span><br><span class="line">主线程工作。。。</span><br><span class="line"><span class="number">14</span>-业务线程--开始工作</span><br><span class="line"><span class="number">14</span>-业务线程--开始工作</span><br><span class="line"><span class="number">14</span>-业务线程--开始工作</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier又称栅栏锁，作用是让一组线程到达某个屏障被阻塞，一直到组内的最后一个线程到达才开放屏障，接着让所有线程继续运行。</p>
<blockquote>
<p><strong>方法：</strong></p>
<p>CyclicBarrier(int parties)：初始化构造方法</p>
<p>CyclicBarrier(int parties, Runnable barrierAction)：barrierAction是当屏障开放后，执行任务线程，如果屏障开放后需要执行什么任务可以写在此线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/25 11:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String,Long&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,<span class="keyword">new</span> CollectThread());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果打印线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String,Long&gt; entry : resultMap.entrySet())&#123;</span><br><span class="line">                stringBuffer.append(<span class="string">&quot;[&quot;</span>+entry.getValue()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;结果集：&quot;</span>+stringBuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;去执行其他业务工作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> id = Thread.currentThread().getId();</span><br><span class="line">            resultMap.put(String.valueOf(id),id);</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(random.nextBoolean())&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>+id);</span><br><span class="line">                    System.out.println(id+<span class="string">&quot;...休眠一下&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(id+<span class="string">&quot;...正在等待&quot;</span>);</span><br><span class="line">                <span class="comment">//调用await</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>+id);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;...继续工作&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyThread());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">15.</span>..正在等待</span><br><span class="line"><span class="number">13.</span>..休眠一下</span><br><span class="line"><span class="number">13.</span>..正在等待</span><br><span class="line"><span class="number">14.</span>..休眠一下</span><br><span class="line"><span class="number">14.</span>..正在等待</span><br><span class="line"><span class="number">16.</span>..休眠一下</span><br><span class="line"><span class="number">16.</span>..正在等待</span><br><span class="line"><span class="number">17.</span>..休眠一下</span><br><span class="line"><span class="number">17.</span>..正在等待</span><br><span class="line">结果集：[<span class="number">13</span>][<span class="number">14</span>][<span class="number">15</span>][<span class="number">16</span>][<span class="number">17</span>]</span><br><span class="line">去执行其他业务工作</span><br><span class="line"><span class="number">13.</span>..继续工作</span><br><span class="line"><span class="number">14.</span>..继续工作</span><br><span class="line"><span class="number">15.</span>..继续工作</span><br><span class="line"><span class="number">16.</span>..继续工作</span><br><span class="line"><span class="number">17.</span>..继续工作</span><br></pre></td></tr></table></figure>

<p>说明：五个线程都达到屏障后,屏障开放,然后线程继续执行,并且barrierAction在屏障开放的一瞬间也开始执行</p>
<p><strong>CountDownLatch和CyclicBarrier的区别：</strong></p>
<p>CyclicBarrier的构造函数第一个参数的传入一定是等于线程的个数的，因为一组线程由自身控制。CountDownLatch构造函数的参数传入一般都是大于等于线程，可以通过第三方进行扣减。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore又称信号量，作用于控制同时访问某个特定资源的线程数量，用在流量控制。</p>
<blockquote>
<p><strong>方法：</strong></p>
<p>Semaphore(int)：初始化构造方法，传入int表示最大允许访问的线程数。</p>
</blockquote>
<h2 id="ExChanger"><a href="#ExChanger" class="headerlink" title="ExChanger"></a>ExChanger</h2><p>Exchanger又称交换器，用于在线程之间交换数据，但只能两个线程之间交换数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liyue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/25 14:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;Set&lt;String&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Set&lt;String&gt; firstSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            firstSet.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            firstSet.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            firstSet.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Set&lt;String&gt; exchangeSet = exchanger.exchange(firstSet);</span><br><span class="line">                <span class="keyword">for</span> (String s : exchangeSet)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;firstSet=&quot;</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Set&lt;String&gt; secondSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            secondSet.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            secondSet.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            secondSet.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Set&lt;String&gt; exchangeSet = exchanger.exchange(secondSet);</span><br><span class="line">                <span class="keyword">for</span> (String s : exchangeSet)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;secondSet=&quot;</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">secondSet=A</span><br><span class="line">secondSet=B</span><br><span class="line">secondSet=C</span><br><span class="line">firstSet=<span class="number">1</span></span><br><span class="line">firstSet=<span class="number">2</span></span><br><span class="line">firstSet=<span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/09/22/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//分（用递归megerSort来实现）</span></span><br><span class="line">        mergeSort(array,start,mid);</span><br><span class="line">        mergeSort(array,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="comment">//合</span></span><br><span class="line">        merge(array,start,mid,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建辅助排序的temp数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = start,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j])&#123;</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i,j一旦其中一个超出范围，说明后面的都是大的，直接复制过来</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把temp覆盖到原数组array的部分（从start开始）</span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; temp.length;k++)&#123;</span><br><span class="line">            array[start+k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度O(nlogn)</p>
<p>最好时间复杂度O(nlogn)</p>
<p>最好时间复杂度O(n)</p>
<p>最坏时间复杂度O(nlogn)</p>
<p>空间复杂度O(n)</p>
<p>稳定</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复git rm的文件</title>
    <url>/2022/03/05/%E6%81%A2%E5%A4%8Dgit-rm%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>恢复git rm掉的但未commit的文件</p>
<blockquote>
<p>git reset<br>git checkout 文件名</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2021/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        抽象工厂模式是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，提供了一种创建对象的最佳方式。</p>
<p>​        在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>​        意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>定义两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建实现接口的实体类</p>
<p>形状：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;正方形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>颜色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;绿色&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>​        创建抽象工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>​        创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;Circle&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;Rectangle&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;Square&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;Red&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;Green&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;Blue&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h3><p>​        创建工厂类生成器类，通过传递形状或颜色信息类获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;Shape&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;Color&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h3><p>​        抽象工厂Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">&quot;Shape&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">&quot;Rectangle&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">&quot;Square&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">&quot;Color&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">圆形</span><br><span class="line">矩形</span><br><span class="line">正方形</span><br><span class="line">红色</span><br><span class="line">绿色</span><br><span class="line">蓝色</span><br></pre></td></tr></table></figure>

<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>​        抽象工厂就是工厂的工厂，通过传递的信息（比如要制造某一类的东西）获取到指定的工厂，然后再由具体的工厂进行生产对象。</p>
<p>​        通俗地说抽象工厂模式就是，“哎，那个那个，我要造车”，“好的老板，找到车工厂了”，“剩下的交给你们了”。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/2021/09/19/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        x = arr[i];</span><br><span class="line">        j = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; x &gt; arr[j])&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度O(n^2^)</p>
<p>最好时间复杂度O(n)</p>
<p>最坏时间复杂度O(n^2^)</p>
<p>空间复杂度O(1)</p>
<p>稳定</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/2021/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><p>​        <strong>互斥条件：</strong>临界资源是独占资源，进程应互斥且排他地使用这些资源。</p>
<p>​        <strong>占有和等待条件：</strong>进程在请求资源得不到满足而等待时，不释放已占用的资源。</p>
<p>​        <strong>不剥夺条件：</strong>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</p>
<p>​        <strong>循环等待条件：</strong>又称环路条件，存在循环等待链，其中每个进程都在等待链中等待下一个进程所持有的的资源，造成这组进程处于永远等待状态。</p>
<blockquote>
<p>​        前三个条件是死锁存在的必要条件，但不是充分条件，第四个条件是前三个条件同时存在时所产生的结果，故条件并不完全独立。但是单独考虑每个条件是有用的，<strong>只要能破坏4个必要条件之一就可以防止死锁</strong>。</p>
</blockquote>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>算法练习-求最长子序列</title>
    <url>/2022/03/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%B1%82%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>输入：[1,1,5,3,2,7]</p>
<p>输出：4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(d[i],d[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d : dp)&#123;</span><br><span class="line">            res = Math.max(res,d);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/09/18/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>​        1.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>　　2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>　　3. 任意节点的左、右子树也分别为二叉查找树。</p>
<p>　　4. 没有键值相等的节点（no duplicate nodes）。</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>​        自平衡二叉查找树，任意节点的子树的高度差都小于等于1，插入、查找、删除的时间复杂度最好情况和最坏情况都维持在O(logN)</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        自平衡二叉查找树，与AVL相似。但红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。其时间复杂度是O(logN)</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>节点是红色或者黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL）是黑色（叶子节点都是为空的节点）</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保了没有一条路径会比其他路径长两倍）</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变</li>
<li>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>
<li>变色：结点的颜色由红变黑或由黑变红。</li>
</ol>
<h3 id="查找实现"><a href="#查找实现" class="headerlink" title="查找实现"></a>查找实现</h3><ol>
<li>从根结点开始查找，把根结点设置为当前结点；</li>
<li>若当前结点为空，返回null；</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较；</li>
<li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li>
</ol>
<h2 id="红黑树相比AVL的优势"><a href="#红黑树相比AVL的优势" class="headerlink" title="红黑树相比AVL的优势"></a>红黑树相比AVL的优势</h2><ol>
<li>当插入了一个节点引起了树的不平衡，AVL和红黑树都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除节点引起树的不平衡时，最坏情况下，AVL需要维护从被删节点到根节点这条路径上所有节点的平衡性，因此需要旋转的量级O(logN)，<strong>而红黑树最多只需3次旋转，只需要O(1)的复杂度</strong>。</li>
<li>红黑树在需要大量插入和删除节点的场景下，效率更高。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2021/08/29/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>博客上传测试，success！</p>
]]></content>
  </entry>
  <entry>
    <title>线程循环打印1-100(wait/notify)</title>
    <url>/2022/03/09/%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B01-100-wait-notify/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CirclePrint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print print = <span class="keyword">new</span> Print(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="string">&quot;t1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print.print(<span class="string">&quot;t2&quot;</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不加volatile也行，因为每次只有一个线程在操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String td, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//当前flag不等于waitFlag就将当前的线程等待</span></span><br><span class="line">                <span class="keyword">while</span> (flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + td + <span class="string">&quot;打印:&quot;</span> + i++);</span><br><span class="line">                <span class="comment">//让下一个线程继续</span></span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="comment">//唤醒</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>解决Next主题开启阅读次数后没有阅读次数四个字的问题</title>
    <url>/2021/09/01/%E8%A7%A3%E5%86%B3Next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E5%90%8E%E6%B2%A1%E6%9C%89%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E5%9B%9B%E4%B8%AA%E5%AD%97%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>打开\themes\next\layout\‘_macro文件夹下的post.swig文件，找到：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.page_pv %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;page-pv&quot;</span>&gt;</span>&#123;&#123; theme.busuanzi_count.page_pv_header &#125;&#125;</span><br><span class="line">  阅读次数:<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;busuanzi-value&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; theme.busuanzi_count.page_pv_footer &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在span class=”busuanzi-value”之前加上文字即可。</p>
<p><strong>为什么用这个方法？</strong></p>
<p>由于看了其他人的办法，去修改next的_config.xml文件下的page_pv_header：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-file-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 阅读次数:</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure>

<p>如上面在page_pv_header图标后加文字，重新提交文章后，页面会报错，页面打开了之后啥都没有了。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/09/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        适配器模式（Adapter Pattern）是作为两个不兼容接口直接的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>​        这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。例如，将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡，读卡器就作为内存卡与笔记本之间的适配器了。</p>
<p>​        意图：在一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建两个接口，一个功能更高级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建两个AdvancedMediaPlayer的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;播放 vlc 格式文件. Name: &quot;</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;播放 mp4 格式文件. Name: &quot;</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>创建实现了MediaPlayer接口的适配类MediaAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;<span class="comment">//创建时生成AdvancedMediaPlayer</span></span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>) )&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();       </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>创建实现了MediaPlayer接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   MediaAdapter mediaAdapter; </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;    </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;mp3&quot;</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;播放 mp3 格式文件. Name: &quot;</span>+ fileName);         </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>)|| audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">         mediaAdapter.play(audioType, fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;无效格式文件. &quot;</span>+</span><br><span class="line">            audioType + <span class="string">&quot; 格式不支持&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"> </span><br><span class="line">      audioPlayer.play(<span class="string">&quot;mp3&quot;</span>, <span class="string">&quot;超人不会飞.mp3&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;mp4&quot;</span>, <span class="string">&quot;流浪地球.mp4&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;vlc&quot;</span>, <span class="string">&quot;精装追女仔.vlc&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;avi&quot;</span>, <span class="string">&quot;精装追女仔2.avi&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">播放 mp3 格式文件. Name: 超人不会飞.mp3</span><br><span class="line">播放 mp4 格式文件. Name: 流浪地球.mp4</span><br><span class="line">播放 vlc 格式文件. Name: 精装追女仔.vlc</span><br><span class="line">无效格式文件. avi 格式不支持</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/2021/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>​        开闭原则的意思是，对外开放，对内修改。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，<strong>我们需要使用接口和抽象类</strong>。</p>
<h2 id="里式代换原则"><a href="#里式代换原则" class="headerlink" title="里式代换原则"></a>里式代换原则</h2><p>​        里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。</p>
<p>​        里氏代换原则是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受影响时，基类才能真正被复用，<strong>而派生类也能够在基类的基础上增加新的行为</strong>。</p>
<p>​        里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>​        这个原则是开闭原则的基础，具体内容：针对接口编程，依赖抽象而不依赖于具体。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>​        使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。</p>
<h2 id="迪米特法则，又称最少知道原则"><a href="#迪米特法则，又称最少知道原则" class="headerlink" title="迪米特法则，又称最少知道原则"></a>迪米特法则，又称最少知道原则</h2><p>​        一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>​        尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>静态代理与动态代理</title>
    <url>/2022/03/08/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>通常通过实现接口实现，对象与代理对象实现对应的接口，在代理对象中引入原对象，执行方法时做其他操作同时调用原对象实现的方法，使用时创建的是代理对象，从而达到增强功能的目的。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>实现：JDK动态代理、CGLIB</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>缺点：类没有实现接口不能进行动态代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LawyerProxy lawyerProxy = <span class="keyword">new</span> LawyerProxy(<span class="keyword">new</span> Complainant());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1 当前类加载器</span></span><br><span class="line"><span class="comment">         * 参数2 代理类要实现的接口</span></span><br><span class="line"><span class="comment">         * 参数3 InvocationHandler，写增强方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Speaker speaker = (Speaker) Proxy.newProxyInstance(</span><br><span class="line">            	ProxyDemo.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Speaker.class&#125;, </span><br><span class="line">            	lawyerProxy);</span><br><span class="line">        speaker.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LawyerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LawyerProxy</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;speak&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用法律&quot;</span>);</span><br><span class="line">            method.invoke(object,args);</span><br><span class="line">            System.out.println(<span class="string">&quot;打人不行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Speaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complainant</span> <span class="keyword">implements</span> <span class="title">Speaker</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;他打我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">使用法律</span><br><span class="line">他打我</span><br><span class="line">打人不行</span><br></pre></td></tr></table></figure>

<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>不要求本体实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LawyerProxy lawyerProxy = <span class="keyword">new</span> LawyerProxy(<span class="keyword">new</span> Complainant());</span><br><span class="line"></span><br><span class="line">        Complainant complainant = (Complainant) Enhancer.create(Complainant.class, lawyerProxy);</span><br><span class="line">        complainant.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LawyerProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LawyerProxy</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;speak&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用法律&quot;</span>);</span><br><span class="line">            method.invoke(object,args);</span><br><span class="line">            System.out.println(<span class="string">&quot;打人不行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complainant</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;他打我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">使用法律</span><br><span class="line">他打我</span><br><span class="line">打人不行</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/09/23/MySQL/</url>
    <content><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>​        MySQL是一种开源的关系型数据库管理系统（RDBMS）。</p>
<h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2 存储引擎"></a>2 存储引擎</h2><h3 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h3><p>​        MySQL默认的存储引擎，支持事务、行锁和外键等操作</p>
<h3 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h3><p>​        MySQL 5.1版本前的默认存储引擎，并发性比较差，不支持事务和外键等操作，默认的锁粒度是表级别的。</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h2><h3 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h3><p>​        TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别占用8、16、24、32、64位存储空间。INT(3)中的3只是表示显示字符的个数，没有实际意义。例如插入数据1，实际存储的数据为001</p>
<h3 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a>3.2 浮点型</h3><p>​        FLOAT、DOUBLE、DECIMAL，DECIMAL利用字符串进行处理的，能存储精确的小数，但是效率比FLOAT、DOUBLE低。FLOAT(5,2)表示一共5位，两位是小数。</p>
<h3 id="3-3-字符串型"><a href="#3-3-字符串型" class="headerlink" title="3.3 字符串型"></a>3.3 字符串型</h3><p>​        CHAR和VARCHAR，VARCHAR用于存储可变长字符串，相比于定长的CHAR更节省空间。但对于经常变更的数据使用CHAR更好，不容易产生碎片。对于短的列也是使用CHAR更好，效率更高。</p>
<p>​        一般避免使用TEXT、BLOB等类型，因为查询时会使用临时表产生性能开销。</p>
<h3 id="3-4-日期"><a href="#3-4-日期" class="headerlink" title="3.4 日期"></a>3.4 日期</h3><p>​        常用的日期类型有year、time、date、datetime、timestamp等，datetime保存从1000年到9999年的时间，精确到秒，使用8字节的存储空间，与时区无关。</p>
<p>​        timestamp和UNIX的时间戳相同，保存从1970年1月1日午夜到2038年的时间，精确到秒，使用4个字节的存储空间，与时区无关。</p>
<p>​        通常使用timestamp比datetime有更高的空间效率。</p>
<h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4 索引"></a>4 索引</h2><p>​        索引是对数据库表的一列或多列的值进行排序的一种结构，使用索引可以快速访问数据库表中特定信息。索引就好像一本书的目录。</p>
<h3 id="4-1-索引优缺点"><a href="#4-1-索引优缺点" class="headerlink" title="4.1 索引优缺点"></a>4.1 索引优缺点</h3><p><strong>优点：</strong></p>
<blockquote>
<ol>
<li>加快数据检索速度。</li>
<li>将随机I/O变成了顺序I/O（因为B+数的叶子节点是连接在一起的）</li>
<li>加速表与表之间的连接</li>
</ol>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ol>
<li>索引需要额外占用物理空间</li>
<li>维护索引需要花费时间，例如对数据进行增删改的时候都需要维护索引。</li>
</ol>
</blockquote>
<h3 id="4-2-索引的数据结构"><a href="#4-2-索引的数据结构" class="headerlink" title="4.2 索引的数据结构"></a>4.2 索引的数据结构</h3><p>​        索引的数据结构主要有B+树和哈希表，对应的索引分别是B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，<strong>默认索引是B+树索引</strong>。</p>
<p><strong>B+树索引：</strong></p>
<blockquote>
<p>B+树中，记录节点都是按照键值大小顺序放在叶子节点上。</p>
<p>B+树索引又可以分为主索引和辅助索引，主索引为聚簇索引，辅助索引为非聚簇索引。</p>
<p>聚簇索引是以主键作为B+树索引的键值所构成B+树索引，聚簇索引的叶子节点存储着完整的数据记录。</p>
<p>非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引查询时，会先找到主键值，然后根据聚簇索引找到对应的数据域。即数据和索引分开存储。</p>
</blockquote>
<p><strong>哈希索引：</strong></p>
<blockquote>
<p>哈希索引是基于哈希表的，对每一行数据，存储引擎会对索引列进行哈希算法计算得到哈希码，并且哈希算法要尽量保证哈希码是不同的。</p>
<p>将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样在查找一个数据时时间复杂度是O(1)，一般多用于精确查找。</p>
</blockquote>
<p><strong>B+树索引和哈希索引的区别：</strong></p>
<blockquote>
<p>B+树索引多用于除了精确查找外的其他查找，哈希索引多用于精确的等值查找。大多数情况还是使用B+树索引。</p>
<p>哈希索引不支持排序，因为哈希表无序的。</p>
<p>哈希索引不支持范围查找。</p>
<p>哈希索引不支持模糊查询及多列索引的最左前缀匹配。</p>
<p>哈希索引存在哈希冲突，性能不稳定。B+树索引性能相对稳定，每次查询都是从根节点到叶子节点。</p>
</blockquote>
<h3 id="4-3-索引的类型"><a href="#4-3-索引的类型" class="headerlink" title="4.3 索引的类型"></a>4.3 索引的类型</h3><p>​        MySQL索引主要有FULLTEXT、HASH、BTREE、RTREE</p>
<p><strong>FULLTEXT：</strong></p>
<blockquote>
<p>全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL 5.6.4以上支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等。</p>
<p>多在CHAR、VARCHAR、TEXT等数据类型上创建全文索引。全文索引主要用来解决where name like “%li%”等文本的模糊查询效率低的问题。</p>
</blockquote>
<p><strong>HASH：</strong></p>
<blockquote>
<p>哈希索引，哈希索引多用于等值查询，效率高，但不支持排序、范围查询及模糊查询等。</p>
</blockquote>
<p><strong>BTREE：</strong></p>
<blockquote>
<p>B+树索引，支持排序、分组、范围查询、模糊查询等，性能稳定。</p>
</blockquote>
<p><strong>RTREE：</strong></p>
<blockquote>
<p>空间数据索引，多用于地理数据的存储，相比于其他索引，空间索引的优势在于范围查找</p>
</blockquote>
<h3 id="4-4-索引的种类"><a href="#4-4-索引的种类" class="headerlink" title="4.4 索引的种类"></a>4.4 索引的种类</h3><p><strong>主键索引：</strong></p>
<p>数据列不允许重复，不能为NULL，一个表只能有一个主键索引。</p>
<p><strong>组合索引：</strong></p>
<p>由多列值组成的索引。</p>
<p><strong>唯一索引：</strong></p>
<p>数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。</p>
<p><strong>全文索引：</strong></p>
<p>对文本内容进行搜索。</p>
<p><strong>普通索引：</strong></p>
<p>基本的索引类型，可以为NULL。</p>
<h3 id="4-5-索引创建"><a href="#4-5-索引创建" class="headerlink" title="4.5 索引创建"></a>4.5 索引创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index index_name on table_name (column_list)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key,</span><br><span class="line">	information text,</span><br><span class="line">	FULLTEXT KEY(information)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name add index index_name (column_list)</span><br></pre></td></tr></table></figure>



<h3 id="4-6-最左匹配原则"><a href="#4-6-最左匹配原则" class="headerlink" title="4.6 最左匹配原则"></a>4.6 最左匹配原则</h3><p>从最左边为起点开始连续匹配，遇到范围查询（&lt;、&gt;、between、like）会停止匹配。</p>
<blockquote>
<p>比如建立索引（a，b，c）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table_name where a=1 and c=2</span><br><span class="line">//只有a列使用了索引，中间跳过了b，不是连续了</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table_name where a=1 and b &lt; 3 and c &lt; 1</span><br><span class="line">//只有a列和b列使用了索引</span><br></pre></td></tr></table></figure>

<p><strong>索引失效：</strong></p>
<blockquote>
<p>以下情况会使索引失效：</p>
<ol>
<li>条件中使用or</li>
<li>在索引上进行计算，如a+1 = 2</li>
<li>对索引列使用函数，如abs(a) = 1</li>
<li>在索引上使用 !=、&lt;&gt;进行判断</li>
<li>在索引上使用is null、is not null</li>
</ol>
</blockquote>
<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5 事务"></a>5 事务</h2><p>​        事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
<h3 id="5-1-四大特性"><a href="#5-1-四大特性" class="headerlink" title="5.1 四大特性"></a>5.1 四大特性</h3><p><strong>原子性(A)：</strong></p>
<p>包含的事务操作要么全部成功要么全部失败。</p>
<p><strong>一致性(C)：</strong></p>
<p>事务执行前后状态是一致的。</p>
<p><strong>隔离性(I)：</strong></p>
<p>一个事务所修改在最终提交之前，对其他事务是不可见的。</p>
<p><strong>持久性(D)：</strong></p>
<p>数据一旦提交，其所作的修改将永久地保存到数据中。</p>
<h3 id="5-2-并发一致性问题"><a href="#5-2-并发一致性问题" class="headerlink" title="5.2 并发一致性问题"></a>5.2 并发一致性问题</h3><p>多个事务并发执行时会出现：</p>
<p><strong>脏读：</strong></p>
<p>​        事务A更新了数据，但还没提交，此时事务B读取到了事务A更新的数据，然后事务A回滚了，事务B读到的数据就成为了脏数据。</p>
<p><strong>不可重复读：</strong></p>
<p>​        事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。</p>
<p><strong>幻读：</strong></p>
<p>​        事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前的数据不一致。</p>
<p><strong>丢失修改：</strong></p>
<p>​        事务A和事务B都对同一个数据进行修改，事务A先修改了，事务B随后修改，事务B覆盖了事务A的修改。</p>
<h3 id="5-3-隔离级别"><a href="#5-3-隔离级别" class="headerlink" title="5.3 隔离级别"></a>5.3 隔离级别</h3><p><strong>读未提交：</strong></p>
<p>一个事务在提交前，它的修改对其他事务是可见的。</p>
<p><strong>读已提交：</strong></p>
<p>一个事务提交后，它的修改才能被其他事务看到。可解决脏读问题。</p>
<p><strong>可重复读（MySQL默认级别）：</strong></p>
<p>在同一个事务中多次读取到的数据时一致的。可解决脏读、不可重复读问题。</p>
<p><strong>串行化：</strong></p>
<p>需要加锁实现，会强制事务串行执行。可解决脏读、不可重复读、幻读问题。</p>
<h3 id="5-4-MVCC"><a href="#5-4-MVCC" class="headerlink" title="5.4 MVCC"></a>5.4 MVCC</h3><p>​        multiple version concurrent control，一种控制并发的方法，主要用来提高数据库的并发性能。MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读（只用mvcc不能解决幻读）、不可重复读等问题，但是不能解决丢失修改问题。</p>
<blockquote>
<p>当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修改当前记录，所有会对读取的记录加锁。</p>
<p>快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。</p>
</blockquote>
<p><strong>实现原理：</strong></p>
<blockquote>
<p>–版本号</p>
<p>系统版本号，是一个自增的ID，每开启一个事务，系统版本号都会递增。</p>
<p>事务版本号：事务版本号是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时间顺序。</p>
</blockquote>
<blockquote>
<p>–行记录隐藏的列</p>
<p>DB_ROW_ID：所需空间6byte，隐含的自增ID，用例生成聚簇索引，如果数据表没有指定聚簇索引，InnoDB会利用这个隐藏ID创建聚簇索引。</p>
<p>DB_TRX_ID：所需空间dbyte，最近修改的事务ID，记录创建这条记录或最后一次修改这条记录的事务ID。</p>
<p>DB_ROLL_PTR：所需空间7byte，回滚指针，指向这条记录的上一个版本。</p>
</blockquote>
<blockquote>
<p>–undo日志</p>
<p>MVCC使用到的快照会存储在undo日志中，该日志通过回滚指针将一个个数据行的所有快照连接起来。</p>
</blockquote>
<p><strong>在重复读的隔离级别下，InnoDB的工作流程：</strong></p>
<blockquote>
<p>Select</p>
<p>当前事务所要查询的数据行快照的<strong>创建版本号</strong>必须小于当前事务的版本号，因为要保证当前事务读取的数据行的快照要么是当前事务开始前就已经存在的，要么就是当前事务自身插入或修改过的。</p>
<p>当前事务所要读取的数据行快照的<strong>删除版本号</strong>必须是大于当前事务的版本号，如果是小于等于的话，表示该数据行快照已经被删除，不能读取。</p>
</blockquote>
<blockquote>
<p>Insert</p>
<p>将当前系统版本号作为数据行快照的创建版本号。</p>
</blockquote>
<blockquote>
<p>Delete</p>
<p>将当前系统版本号作为数据行快照的删除版本号。</p>
</blockquote>
<blockquote>
<p>Update</p>
<p>保存当前系统版本号为更新前的数据行快照创建行版本号，并保存当前系统版本号为更新后的数据行快照的删除版本号。即先删除再插入。</p>
</blockquote>
<h2 id="6-数据库锁"><a href="#6-数据库锁" class="headerlink" title="6 数据库锁"></a>6 数据库锁</h2><p>当数据库有并发事务的时候，保证数据库问顺序的机制称为锁机制。</p>
<p><strong>隔离级别与锁的关系：</strong></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>总是读取最新的数据，无需加锁</td>
</tr>
<tr>
<td>读已提交</td>
<td>读取数据时加共享锁，读取数据后释放共享锁</td>
</tr>
<tr>
<td>可重复读</td>
<td>读取数据时加共享锁，事务结束后释放共享锁</td>
</tr>
<tr>
<td>串行化</td>
<td>锁定整个范围的键，一直持有锁指定事务结束</td>
</tr>
</tbody></table>
<h3 id="6-1-锁的类型"><a href="#6-1-锁的类型" class="headerlink" title="6.1 锁的类型"></a>6.1 锁的类型</h3><p>按锁的粒度分，MyISAM默认采用表级锁，InnoDB默认采用行级锁</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>资源开销</th>
<th>加锁速度</th>
<th>是否会出现死锁</th>
<th>锁的粒度</th>
<th>并发度</th>
</tr>
</thead>
<tbody><tr>
<td>表级锁</td>
<td>小</td>
<td>快</td>
<td>不会</td>
<td>大</td>
<td>低</td>
</tr>
<tr>
<td>页面锁</td>
<td>一般</td>
<td>一般</td>
<td>不会</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>行级锁</td>
<td>大</td>
<td>慢</td>
<td>会</td>
<td>小</td>
<td>高</td>
</tr>
</tbody></table>
<p>按锁的类别分：分为共享锁和排他锁</p>
<blockquote>
<p><strong>共享锁：</strong>共享锁又称为读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁</p>
<p><strong>排他锁：</strong>排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。</p>
</blockquote>
<h3 id="6-2-InnoDB引擎的行锁模式"><a href="#6-2-InnoDB引擎的行锁模式" class="headerlink" title="6.2 InnoDB引擎的行锁模式"></a>6.2 InnoDB引擎的行锁模式</h3><p>InnoDB还有两种内部使用的意向锁，两种意向锁都是表锁。</p>
<ul>
<li>意向共享锁：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。</li>
<li>意向排他锁：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的IX锁。</li>
</ul>
<p>有了意向锁，一个事务想对某个表加X锁，只需要检查是否有其他事务对这个表加了X/IX/S/IS锁即可</p>
<p>行锁实现：InnoDB的行锁是通过索引上的索引项加锁实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录进行加锁。</p>
<blockquote>
<p>Record lock：对索引项加锁。</p>
<p>Grap lock：对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的“间隙”加锁。</p>
<p>Next-key lock：前两种放入组合，对记录及前面的间隙加锁</p>
</blockquote>
<p><strong>InnoDB行锁的特性：</strong></p>
<p>如果不通过索引条件检索数据，那么InnoDB将对表中所有记录加锁，实际产生的效果和表锁是一样的。</p>
<blockquote>
<p>在可重复读隔离级别下，使用MVCC+Next-Key lock 可以解决幻读问题。</p>
</blockquote>
<h3 id="6-3-数据库的乐观锁和悲观锁"><a href="#6-3-数据库的乐观锁和悲观锁" class="headerlink" title="6.3 数据库的乐观锁和悲观锁"></a>6.3 数据库的乐观锁和悲观锁</h3><p><strong>乐观锁：</strong></p>
<p>系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则提交失败。</p>
<p>实现方式：一般通过版本号和CAS算法实现。</p>
<p><strong>悲观锁：</strong></p>
<p>假设会发生并发冲突，屏蔽一切可能违反数据的完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候会上锁。</p>
<p>实现方式：通过数据库的锁机制实现，对查询语句添加for update。</p>
<h3 id="6-4-MySQL避免死锁"><a href="#6-4-MySQL避免死锁" class="headerlink" title="6.4 MySQL避免死锁"></a>6.4 MySQL避免死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或由于彼此通信造成的一种阻塞现象。</p>
<p><strong>如何避免死锁或锁冲突？</strong></p>
<blockquote>
<p>如果不同程序并发存取多个表，尽量以相同的顺序访问表。</p>
<p>在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。</p>
<p>在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时再申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突。</p>
<p>尽量使用较低的隔离级别。</p>
<p>尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会。</p>
<p>合理选择事务的大小，小事务发生锁冲突的概率更低。</p>
<p>尽量用相等的条件访问数据，可以避免Next-key锁对并发插入的影响。</p>
<p>不要申请超过实际需要的锁级别，查询时尽量不要显式加锁。</p>
<p>对于一些特定的事务，可以用表锁来提高处理速度或减少死锁的概率。</p>
</blockquote>
<h2 id="7-SQL语句"><a href="#7-SQL语句" class="headerlink" title="7 SQL语句"></a>7 SQL语句</h2><p>DDL（数据定义语言）、DQL（数据查询语言）、DML（数据操纵语言）、DCL（数据控制语言）</p>
<h3 id="7-1-SQL约束"><a href="#7-1-SQL约束" class="headerlink" title="7.1 SQL约束"></a>7.1 SQL约束</h3><p>主键约束、外键约束、唯一约束、默认约束、check约束</p>
<h3 id="7-2-连接查询"><a href="#7-2-连接查询" class="headerlink" title="7.2 连接查询"></a>7.2 连接查询</h3><p><strong>外连接</strong></p>
<p>左外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。</p>
<p>右外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。</p>
<p>全外连接：MySQL不支持</p>
<p><strong>内连接</strong></p>
<p>只显示符合条件的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select A.*,B.* from A inner join B on A.id = B.id</span><br></pre></td></tr></table></figure>

<h3 id="7-3-in和exists的区别"><a href="#7-3-in和exists的区别" class="headerlink" title="7.3 in和exists的区别"></a>7.3 in和exists的区别</h3><ul>
<li><p>使用exists时会先进行外表查询，将查询到的每行数据带入到内表查询中看是否满足条件；</p>
</li>
<li><p>使用in一般会先进行内表查询获取结果集，然后对外表查询匹配结果集，返回数据</p>
</li>
<li><p>in在内表查询或者外表查询过程中都会用到索引</p>
</li>
<li><p>exists仅在内表查询时会用到索引</p>
</li>
<li><p>not exists 效率比not in效率高，not in进行了全表扫描，没有使用索引</p>
</li>
</ul>
<h3 id="7-4-drop、delete和truncate的区别？"><a href="#7-4-drop、delete和truncate的区别？" class="headerlink" title="7.4 drop、delete和truncate的区别？"></a>7.4 drop、delete和truncate的区别？</h3><p>drop：速度快，DDL，不可回滚，删除整个表</p>
<p>delete：逐行删除，DML，可以回滚，表结构不删除</p>
<p>truncate：较快，DDL，不可回滚，表结构不删除</p>
<h3 id="7-5-UNION和UNION-ALL的区别？"><a href="#7-5-UNION和UNION-ALL的区别？" class="headerlink" title="7.5 UNION和UNION ALL的区别？"></a>7.5 UNION和UNION ALL的区别？</h3><p>union和union all的作用都是将两个结果集合并到一起</p>
<p>union会对结果去重并排序，union all直接直接返回合并后的结果，不去重也不进行排序。</p>
<p>union all的性能比union性能好。</p>
<h3 id="7-6-临时表"><a href="#7-6-临时表" class="headerlink" title="7.6 临时表"></a>7.6 临时表</h3><p>MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。</p>
<blockquote>
<p>临时表主要分为内存临时表和磁盘临时表两种。</p>
</blockquote>
<p><strong>使用临时表的情况：</strong></p>
<ul>
<li>FROM中的子查询</li>
<li>DISTINCT查询并加上ORDER BY</li>
<li>ORDER BY和GROUP BY的子句不一样时会产生临时表</li>
<li>使用UNION查询会产生临时表</li>
</ul>
<h3 id="7-7-慢查询"><a href="#7-7-慢查询" class="headerlink" title="7.7 慢查询"></a>7.7 慢查询</h3><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志</p>
<h3 id="7-8-为什么要设置主键？"><a href="#7-8-为什么要设置主键？" class="headerlink" title="7.8 为什么要设置主键？"></a>7.8 为什么要设置主键？</h3><p>主键是唯一区分表中每一行的唯一标识，如果没有主键，更新或者删除表中特定的行会很困难，因为不能唯一准确地标识某一行</p>
<h3 id="7-9-ID与UUID"><a href="#7-9-ID与UUID" class="headerlink" title="7.9 ID与UUID"></a>7.9 ID与UUID</h3><p>MySQL的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可</p>
<p>而UUID，ID是随机生成的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降</p>
<h3 id="7-10-字段为什么要设置成not-null"><a href="#7-10-字段为什么要设置成not-null" class="headerlink" title="7.10 字段为什么要设置成not null?"></a>7.10 字段为什么要设置成not null?</h3><p>NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。</p>
<p><strong>设置not null：</strong></p>
<ul>
<li>NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。</li>
<li>B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题。</li>
<li>NOT IN子查询在有NULL值的情况下返回的结果都是空值。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring复习</title>
    <url>/2021/09/04/Spring%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1-特征"><a href="#1-特征" class="headerlink" title="1 特征"></a>1 特征</h2><p>​        <strong>轻量级：</strong>从大小与开销方面而言Spring都是轻量级的，完整的Spring框架可以在一个大小只有1M多的JAR文件里发布。</p>
<p>​        <strong>控制反转：</strong>通过控制反转IOC的技术促进了低耦合，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</p>
<p>​        <strong>面向切面：</strong>支持面向切面编程，并且把应用业务逻辑和系统服务分开。</p>
<p>​        <strong>容器：</strong>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器。</p>
<p>​        <strong>框架：</strong>Spring可以将简单的组件配置、组合成为复杂的应用。应用对象被声明式地组合，典型的是在一个XML文件里。</p>
<h2 id="2-常用模块"><a href="#2-常用模块" class="headerlink" title="2 常用模块"></a>2 常用模块</h2><p>​        <strong>核心容器：</strong>提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，是工厂模式的实现。BeanFactory使用控制反转（IOC）模式将程序的配置和依赖性规范与实际应用程序代码分开。</p>
<p>​        <strong>Spring上下文：</strong>Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，例如JNDI（Java命名和目录接口）、EJB（企业Java Beans）、电子邮件、国际化、校验和深度功能。</p>
<p>​        <strong>Spring AOP：</strong>Spring AOP模块直接将面向切面的编程功能集成到Spring框架中，可以将一些通用任务，如安全、事务、日志等集中进行处理，提高复用性和管理的便捷性。</p>
<p>​        <strong>Spring DAO：</strong>为JDBC抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库提供商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。</p>
<p>​        <strong>Spring ORM：</strong>Spring插入了若干ORM框架，从而提供了ORM的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵循Spring的通用事务和DAO异常层次结构。</p>
<p>​        <strong>Spring Web：</strong>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。所以，Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
<p>​        <strong>Spring MVC：</strong>MVC框架是一个全功能的构建Web应用程序的MVC实现。</p>
<h2 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3 常用注解"></a>3 常用注解</h2><p>​        <strong>@Controller：</strong>用于标注控制层组件，标注的类表明为一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类方法，并检测该方法是否使用了@RequestMapping注解。</p>
<p>​        <strong>@RestController：</strong>等于@Controller加@ResponseBody组合</p>
<p>​        <strong>@Component：</strong>泛指组件，当组件不好归类就使用这个。</p>
<p>​        <strong>@Repository：</strong>用于标注Dao层，在DaoImpl类上注解。</p>
<p>​        <strong>@Service：</strong>用于标注业务层组件。</p>
<p>​        <strong>@ResponseBody：</strong>异步请求，该注解用于将Controller的方法方法返回的对象，通过是对的HttpMessageConverter转换为指定格式后写入到Response对象的body数据区。</p>
<p>​        <strong>@RequestMapping：</strong>用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>​        <strong>@Value：</strong>对普通类型进行注入</p>
<p>​        <strong>@Autowired：</strong>按默认类型进行自动装配。可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过@Autowired的使用来消除set、get方法。</p>
<p>​        <strong>@Qualifier：</strong>强制使用名称注入。</p>
<p>​        <strong>@Resource：</strong>相当于@Autowired加@Qualifier，java提供的</p>
<p>​        <strong>@PathVariable：</strong>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出URL模板中的变量作为参数。</p>
<p>​        <strong>@RequestParam：</strong>主要用于在SpringMVC后台控制层获取参数，取出url模板中的变量作为参数。</p>
<p>​        <strong>@RequestHeader：</strong>可以把Request请求header部分的值绑定到方法的参数上。</p>
<p>​        <strong>@ModelAttribute：</strong>在Controller的所有方法调用前，先执行此注解，可用于方法和方法参数中。@ModelAttribute会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中</p>
<p>​        <strong>@SessionAttributes：</strong>将值放到session作用域中，写在class上。</p>
<p>​        <strong>@Valid：</strong>实体数据校验，可结合hibernate validator一起使用</p>
<p>​        <strong>@CookieValue：</strong>获取Cookie中的值</p>
<h2 id="4-Spring-IOC原理"><a href="#4-Spring-IOC原理" class="headerlink" title="4 Spring IOC原理"></a>4 Spring IOC原理</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>​        Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 Ioc 容器在完成这些底层工作的基础上，还提供 了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p>
<h3 id="4-2容器"><a href="#4-2容器" class="headerlink" title="4.2容器"></a>4.2容器</h3><p>​        Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配 置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准 备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现</p>
<blockquote>
<p><strong>应用程序的Bean配置信息（XML文件、带@Configuration注解的Java类、注解）</strong></p>
<p>↓    生成注册表</p>
<p>—————-Spring 容器—————-</p>
<p><strong>Bean配置注册表</strong></p>
<p>—————-Spring 容器—————-</p>
<p>↓    实例化Bean</p>
<p><strong>Bean实现类</strong></p>
<p>↓    Bean实例放入缓存池</p>
<p>—————-Spring 容器—————-</p>
<p><strong>Bean缓存池</strong></p>
<p>—————-Spring 容器—————-</p>
<p>↓</p>
<p><strong>应用程序使用Bean实例</strong></p>
</blockquote>
<h3 id="4-3容器实现"><a href="#4-3容器实现" class="headerlink" title="4.3容器实现"></a>4.3容器实现</h3><h4 id="BeanFactory-框架基础设施"><a href="#BeanFactory-框架基础设施" class="headerlink" title="BeanFactory-框架基础设施"></a>BeanFactory-框架基础设施</h4><p>​        BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层 的 BeanFactory</p>
<p>​        <strong>BeanDefinitionRegistry 注册表：</strong> </p>
<blockquote>
<p>​        Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示， 它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。 </p>
</blockquote>
<p>​         <strong>BeanFactory 顶层接口：</strong> </p>
<blockquote>
<p>​        位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中 返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展。</p>
</blockquote>
<p>​         <strong>ListableBeanFactory（继承于BeanFactory ）：</strong> </p>
<blockquote>
<p>​        该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法； </p>
</blockquote>
<p>​        <strong>HierarchicalBeanFactory 父子级联（继承于BeanFactory ）：</strong></p>
<blockquote>
<p>​        父子级联 Ioc 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 Ioc 容器可以建立父子层级关联的容器体系，<strong>子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean</strong>。</p>
<p>​        Spring 使用父子容器实 现了很多功能，<strong>比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久 层的 Bean 位于父容器中</strong>。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务 层和持久层的 Bean 则看不到展现层的 Bean。</p>
</blockquote>
<p>​        <strong>ConfigurableBeanFactory（继承于HierarchicalBeanFactory）  ：</strong></p>
<blockquote>
<p>​        是一个重要的接口，增强了 Ioc 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</p>
</blockquote>
<p>​        <strong>AutowireCapableBeanFactory 自动装配 （继承于BeanFactory ）：</strong></p>
<blockquote>
<p>​         定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法； </p>
</blockquote>
<p>​        <strong>SingletonBeanRegistry 运行期间注册单例 Bean ：</strong></p>
<blockquote>
<p>​    定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean  来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从 Ioc容器的缓存中获取 Bean 实例。</p>
<p>​        Spring 在 DefaultSingletonBeanRegistry 类中提供了一 个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。</p>
</blockquote>
<p>​        <strong>依赖日志框架：</strong></p>
<blockquote>
<p>​        在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提 供 Log4J 配置文件，这样启动 Spring 容器才不会报错</p>
</blockquote>
<h4 id="ApplicationContext-面向开发应用"><a href="#ApplicationContext-面向开发应用" class="headerlink" title="ApplicationContext 面向开发应用"></a>ApplicationContext 面向开发应用</h4><p>​        ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。 ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础 上，还通过多个其他的接口扩展了 BeanFactory 的功能。</p>
<p>​        <strong>ClassPathXmlApplicationContext：</strong></p>
<blockquote>
<p>​        默认从类路径加载配置文件 </p>
</blockquote>
<p>​        <strong>FileSystemXmlApplicationContext：</strong></p>
<blockquote>
<p>​        默认从文件系统中装载配置文件 </p>
</blockquote>
<p>​        <strong>ApplicationEventPublisher：</strong></p>
<blockquote>
<p>​        让容器拥有发布应用上下文事件的功能，包括容器启动事 件、关闭事件等。 </p>
</blockquote>
<p>​         <strong>MessageSource：</strong></p>
<blockquote>
<p>​        为应用提供 i18n 国际化消息访问的功能； </p>
</blockquote>
<p>​        <strong>ResourcePatternResolver ：</strong> </p>
<blockquote>
<p>​        所 有 ApplicationContext 实现类都实现了类似于 PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</p>
</blockquote>
<p>​        <strong>LifeCycle：</strong></p>
<blockquote>
<p>​        该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要 用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</p>
</blockquote>
<p>​         <strong>ConfigurableApplicationContext：</strong></p>
<blockquote>
<p>​         扩展于 ApplicationContext，它新增加了两个主要 的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动 的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用 上下文。</p>
</blockquote>
<h4 id="WebApplication体系架构"><a href="#WebApplication体系架构" class="headerlink" title="WebApplication体系架构"></a>WebApplication体系架构</h4><p>​        WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的 路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得 ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext  中，以便 Web 应用环境可以访问 Spring 应用上下文。</p>
<h2 id="5-Spring-Bean的作用域"><a href="#5-Spring-Bean的作用域" class="headerlink" title="5 Spring Bean的作用域"></a>5 Spring Bean的作用域</h2><h3 id="5-1-singleton：单例模式"><a href="#5-1-singleton：单例模式" class="headerlink" title="5.1 singleton：单例模式"></a>5.1 singleton：单例模式</h3><p>​        多线程下不安全的，Spring Ioc容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。singleton作用域是Spring中缺省作用域。显示使用：&lt;bean id=”userDao” class=”com.dao” scope=”singleton”/</p>
<h3 id="5-2-prototype：原型模式"><a href="#5-2-prototype：原型模式" class="headerlink" title="5.2 prototype：原型模式"></a>5.2 prototype：原型模式</h3><p>​        每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的bean实例，每个bean实例都有自己的属性和状态，而singleton全局只有一个。根据经验，对有状态的bean使用prototype作用域，对无状态的bean使用singleton作用域。</p>
<h3 id="5-3-request：一次请求一个实例"><a href="#5-3-request：一次请求一个实例" class="headerlink" title="5.3 request：一次请求一个实例"></a>5.3 request：一次请求一个实例</h3><p>​        在一次 http 请求中，容器会返回该 Bean 的同一实例。而对不同的 http 请求则会 产生新的 bean，而且该 bean 仅在当前 http Request 内有效,当前 http 请求结束，该 bean 实例也将会被销毁。</p>
<h3 id="5-4-seesion"><a href="#5-4-seesion" class="headerlink" title="5.4 seesion"></a>5.4 seesion</h3><p>在一次 http session 中，容器会返回该 bean 的同一实例。而对不同的 Session 请 求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次 session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求 内有效，请求结束，则实例将被销毁。</p>
<h3 id="5-5-global-Session"><a href="#5-5-global-Session" class="headerlink" title="5.5 global Session"></a>5.5 global Session</h3><p>在一个全局的 http session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效</p>
<h2 id="6-Spring-Bean生命周期"><a href="#6-Spring-Bean生命周期" class="headerlink" title="6 Spring Bean生命周期"></a>6 Spring Bean生命周期</h2><h3 id="6-1-实例化"><a href="#6-1-实例化" class="headerlink" title="6.1 实例化"></a>6.1 实例化</h3><p>实例化一个bean</p>
<h3 id="6-2-IOC依赖注入"><a href="#6-2-IOC依赖注入" class="headerlink" title="6.2 IOC依赖注入"></a>6.2 IOC依赖注入</h3><p>按照Spring上下文对实例化的Bean进行配置，就是IOC注入</p>
<h3 id="6-3-BeanNameAware实现-可选"><a href="#6-3-BeanNameAware实现-可选" class="headerlink" title="6.3 BeanNameAware实现(可选)"></a>6.3 BeanNameAware实现(可选)</h3><p>如果这个Bean以及实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值了</p>
<h3 id="6-4-BeanFactoryAware-实现-可选"><a href="#6-4-BeanFactoryAware-实现-可选" class="headerlink" title="6.4 BeanFactoryAware 实现 (可选)"></a>6.4 BeanFactoryAware 实现 (可选)</h3><p> 如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory， setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean， 只需在 Spring 配置文件中配置一个普通的 Bean 就可以）</p>
<h3 id="6-5-ApplicationContextAware-实现-可选"><a href="#6-5-ApplicationContextAware-实现-可选" class="headerlink" title="6.5 ApplicationContextAware 实现 (可选)"></a>6.5 ApplicationContextAware 实现 (可选)</h3><p>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也 可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接 口，有更多的实现方法）</p>
<h3 id="6-6-postProcessBeforeInitialization-接口实现-初始化预处理"><a href="#6-6-postProcessBeforeInitialization-接口实现-初始化预处理" class="headerlink" title="6.6 postProcessBeforeInitialization 接口实现-初始化预处理"></a>6.6 postProcessBeforeInitialization 接口实现-初始化预处理</h3><p>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用 postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用 作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术</p>
<h3 id="6-7-InitializingBean接口"><a href="#6-7-InitializingBean接口" class="headerlink" title="6.7 InitializingBean接口"></a>6.7 InitializingBean接口</h3><p>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法</p>
<h3 id="6-8-init-method"><a href="#6-8-init-method" class="headerlink" title="6.8 init-method"></a>6.8 init-method</h3><p>如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法</p>
<h3 id="6-9-postProcessAfterInitialization"><a href="#6-9-postProcessAfterInitialization" class="headerlink" title="6.9 postProcessAfterInitialization"></a>6.9 postProcessAfterInitialization</h3><p>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法。 注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean 是一个 Singleton 的，所以一 般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton</p>
<h3 id="6-10-Destroy-过期自动清理阶段"><a href="#6-10-Destroy-过期自动清理阶段" class="headerlink" title="6.10 Destroy 过期自动清理阶段"></a>6.10 Destroy 过期自动清理阶段</h3><p> 当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法； </p>
<h3 id="6-11-destroy-method-自配置清理"><a href="#6-11-destroy-method-自配置清理" class="headerlink" title="6.11 destroy-method 自配置清理"></a>6.11 destroy-method 自配置清理</h3><p> 最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p>
<h3 id="过程简述"><a href="#过程简述" class="headerlink" title="过程简述"></a>过程简述</h3><blockquote>
<p>bean生命周期：</p>
<p>实例化    —&gt;    属性注入    —&gt;    执行setBeanName方法    —&gt;    执行setApplicationContext方法    —&gt;    执行postProcessBeforeInitialization方法    —&gt;    执行afterPropertiesSet方法    —&gt;    执行我们自定义的bean初始化方法    —&gt;    执行postProcessAfterInitialization方法    —&gt;    使用bean    —&gt;    容器关闭执行destroy</p>
<p>bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制 初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</p>
<p>bean id=”xxx” class=”xxx” init-method=”初始化方法” destroy-method=”销毁方法”</p>
</blockquote>
<h3 id="我的描述"><a href="#我的描述" class="headerlink" title="我的描述"></a>我的描述</h3><h2 id="7-Spring-依赖注入"><a href="#7-Spring-依赖注入" class="headerlink" title="7 Spring 依赖注入"></a>7 Spring 依赖注入</h2><p>​        依赖注入是建立在一个有三个参与者的场景下的，三个参与者分别是对象、容器、外部资源。<br>​        对象依赖于容器，容器讲外部资源注入对象。比如在在三层架构中service层的某一个bean需要dao层的bean进行获取数据，这时候就可以通过spring将dao层的bean注入到service层的bean中，然后便可使用。</p>
<h3 id="7-1-造器注入"><a href="#7-1-造器注入" class="headerlink" title="7.1 造器注入"></a>7.1 造器注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*带参数，方便利用构造器进行注入*/</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CatDaoImpl</span><span class="params">(String message)</span></span>&#123; </span><br><span class="line"> 	<span class="keyword">this</span>. message = message; </span><br><span class="line"> &#125; </span><br><span class="line">&lt;bean id=<span class="string">&quot;CatDaoImpl&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.CatDaoImpl&quot;</span>&gt; </span><br><span class="line">	&lt;constructor-arg value=<span class="string">&quot; message &quot;</span>&gt;&lt;/constructor-arg&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-setter方法注入"><a href="#7-2-setter方法注入" class="headerlink" title="7.2 setter方法注入"></a>7.2 setter方法注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Id</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125; </span><br><span class="line">&#125; </span><br><span class="line">&lt;bean id=<span class="string">&quot;id&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.d &quot;</span>&gt; </span><br><span class="line">    &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;123&quot;</span>&gt;&lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-静态工厂注入"><a href="#7-3-静态工厂注入" class="headerlink" title="7.3 静态工厂注入"></a>7.3 静态工厂注入</h3><p>​        静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所 有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 spring 注入的形式获 取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123; <span class="comment">//静态工厂 </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title">getStaticFactoryDaoImpl</span><span class="params">()</span></span>&#123; </span><br><span class="line">     	<span class="keyword">return</span> <span class="keyword">new</span> StaticFacotryDaoImpl(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> FactoryDao staticFactoryDao; <span class="comment">//注入对象</span></span><br><span class="line">     <span class="comment">//注入对象的 set 方法 </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaticFactoryDao</span><span class="params">(FactoryDao staticFactoryDao)</span> </span>&#123; </span><br><span class="line">     	<span class="keyword">this</span>.staticFactoryDao = staticFactoryDao; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span></span><br><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot; SpringAction&quot;</span> &gt; </span><br><span class="line"> 	&lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt; </span><br><span class="line"> 	&lt;property name=<span class="string">&quot;staticFactoryDao&quot;</span> ref=<span class="string">&quot;staticFactoryDao&quot;</span>&gt;&lt;/property&gt; </span><br><span class="line"> &lt;/bean&gt; </span><br><span class="line">     </span><br><span class="line">&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt; </span><br><span class="line">&lt;bean name=<span class="string">&quot;staticFactoryDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;DaoFactory&quot;</span> factory-method=<span class="string">&quot;getStaticFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-实例工厂注入"><a href="#7-4-实例工厂注入" class="headerlink" title="7.4 实例工厂注入"></a>7.4 实例工厂注入</h3><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123; <span class="comment">//实例工厂 </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> FactoryDao <span class="title">getFactoryDaoImpl</span><span class="params">()</span></span>&#123; </span><br><span class="line">    	 <span class="keyword">return</span> <span class="keyword">new</span> FactoryDaoImpl(); </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> FactoryDao factoryDao; <span class="comment">//注入对象 </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryDao</span><span class="params">(FactoryDao factoryDao)</span> </span>&#123; </span><br><span class="line">     	<span class="keyword">this</span>.factoryDao = factoryDao; </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;SpringAction&quot;</span>&gt; </span><br><span class="line"> 	&lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt; </span><br><span class="line"> 	&lt;property name=<span class="string">&quot;factoryDao&quot;</span> ref=<span class="string">&quot;factoryDao&quot;</span>&gt;&lt;/property&gt; </span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt; </span><br><span class="line">&lt;bean name=<span class="string">&quot;daoFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.DaoFactory&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"> </span><br><span class="line">&lt;bean name=<span class="string">&quot;factoryDao&quot;</span> factory-bean=<span class="string">&quot;daoFactory&quot;</span> factory-method=<span class="string">&quot;getFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-注解注入"><a href="#7-5-注解注入" class="headerlink" title="7.5 注解注入"></a>7.5 注解注入</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>默认按类型进行自动装配，作用的对象可以为成员变量，也可以为方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<h4 id="Qualifier-value-“xxx”"><a href="#Qualifier-value-“xxx”" class="headerlink" title="@Qualifier(value=“xxx”)"></a>@Qualifier(value=“xxx”)</h4><p>强制使用指定名称注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userServiceImp&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserSerevice userService;</span><br></pre></td></tr></table></figure>

<h4 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h4><p>在众多相同的Bean中，优先使用@Primary注解的Bean</p>
<h4 id="Resource-name-“xxx”"><a href="#Resource-name-“xxx”" class="headerlink" title="@Resource(name=“xxx”)"></a>@Resource(name=“xxx”)</h4><p>由Java提供，相当于@Autowired加@Qualifier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>

<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><blockquote>
<p>用于注入基本类型和String类型数据</p>
</blockquote>
<p><strong>作用在类上的：</strong></p>
<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><blockquote>
<p>将当前类存入容器，value: 用于指定bean的id，当不写时，默认为当前类的名称且首字母小写。</p>
</blockquote>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><blockquote>
<p>用于表现层</p>
</blockquote>
<h4 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h4><blockquote>
<p>用于业务层</p>
</blockquote>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h4><blockquote>
<p>用于持久层</p>
</blockquote>
<h2 id="8-Spring-AOP原理"><a href="#8-Spring-AOP原理" class="headerlink" title="8 Spring AOP原理"></a>8 Spring AOP原理</h2><h3 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h3><p>“横切”的技术，剖解开封装的对象内部，并<strong>将那些影响了多个类的公共行为封装到一个可重用模块</strong>， 并将其命名为”Aspect”，即切面。所谓”切面”，<strong>简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来</strong>，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未 来的可操作性和可维护性。 </p>
<p>使用”横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，<strong>比如权限认证、日志、事务</strong>。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h3 id="8-2-核心概念"><a href="#8-2-核心概念" class="headerlink" title="8.2 核心概念"></a>8.2 核心概念</h3><ol>
<li>切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象。一个关注点的模块化，这个关注点可能会横切多个对象，例如事务管理。在Spring AOP中可以使用@Aspect注解方式实现。</li>
<li>横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</li>
<li>连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中<strong>连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</strong>。 在程序执行过程中某个特定的点，比如方法调用的时候或处理异常的时候。</li>
<li>切入点（pointcut）：对连接点进行拦截的定义 </li>
<li>通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为<strong>前置、后置、 异常、最终、环绕</strong>通知五类。 </li>
<li>目标对象：代理的目标对象 </li>
<li>织入（weave）：将切面应用到目标对象并导致代理对象创建的过程 </li>
<li>引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。</li>
</ol>
<blockquote>
<p>通知类型：</p>
<p><strong>前置通知（Before advice）：</strong>在某个连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非抛出一个异常）</p>
<p><strong>后置通知（After returning advice）：</strong>在某连接点正常完成后执行的通知，例如一个方法没有抛出任何异常，正常返回。</p>
<p><strong>异常通知（After throwing advice）：</strong>在方法抛出异常退出时执行的通知。</p>
<p><strong>最终通知（After advice）：</strong>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
<p><strong>环绕通知（Around advice）：</strong>包围一个连接点的通知，如方法调用。这是最强大的一种通知类型，环绕通知可以在方法调用前后完成自定义的行为，它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p>
</blockquote>
<h3 id="8-3-AOP两种代理方式"><a href="#8-3-AOP两种代理方式" class="headerlink" title="8.3 AOP两种代理方式"></a>8.3 AOP两种代理方式</h3><p>​        Spring 提供了两种方式来生成代理对象: JDK Proxy 和 CGLib，具体使用哪种方式生成由 AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。</p>
<p>​        默认的策略是如果目标类是接口， 则使用 JDK 动态代理技术，否则使用 CGLib 来生成代理。</p>
<p><strong>JDK 动态接口代理</strong></p>
<blockquote>
<p>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。 InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建 一个符合某一接口的实例，生成目标类的代理对象</p>
</blockquote>
<p><strong>CGLib 动态代理</strong></p>
<blockquote>
<p>CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库， 可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以在运行期动态生成新 的 class。和 JDK 动态代理相比较：<strong>JDK 创建代理有一个限制，就是只能为接口创建代理实例</strong>， 而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDemo</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Pointcut(value=&quot;execution(* com.service.*.*.*(..))&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">point</span><span class="params">()</span></span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">	 <span class="meta">@Before(value=&quot;point()&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">     	System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@AfterReturning(value = &quot;point()&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	 System.out.println(<span class="string">&quot;transaction commit&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">         joinPoint.proceed();</span><br><span class="line">         System.out.println(<span class="string">&quot;transaction commit&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>线程循环打印1-100(park/unpark)</title>
    <url>/2022/03/09/%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B01-100-park-unpark/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CirclePrint2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入park/unpark测试&quot;</span>);</span><br><span class="line">        Print2 print2 = <span class="keyword">new</span> Print2();</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print2.print(<span class="string">&quot;t1&quot;</span>,t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print2.print(<span class="string">&quot;t2&quot;</span>,t1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//先唤醒t1</span></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String td, Thread next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + td + <span class="string">&quot;打印:&quot;</span> + i++);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>多线程实现取钱与存取</title>
    <url>/2022/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8F%96%E9%92%B1%E4%B8%8E%E5%AD%98%E5%8F%96/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//取钱</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                bank.del(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//存钱</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                bank.add(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accout;</span><br><span class="line">    <span class="comment">//true时可以取钱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> accout, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accout = accout;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            accout += money;</span><br><span class="line">            System.out.println(<span class="string">&quot;有钱了,当前账户：&quot;</span> + accout);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (money &gt; accout) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;钱不够&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//通知存钱</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                    <span class="comment">//阻塞</span></span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            accout -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱：&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>线程循环打印1-100(Semaphore)</title>
    <url>/2022/03/12/%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B01-100(Semaphore)/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CirclePrint3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print3 print3 = <span class="keyword">new</span> Print3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print3.print(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print3.print(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置为公平锁</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String td)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + td + <span class="string">&quot;打印:&quot;</span> + i++);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>音乐系统开发问题记录</title>
    <url>/2022/03/15/%E9%9F%B3%E4%B9%90%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a><strong>问题一</strong></h2><p>前端使用audio进行音乐播放，在canplay方法中进行音乐播放的逻辑。使用vuex保存全局数据，刷新页面时做了对vuex全局数据的保存操作。</p>
<p>但有个问题就是，前面要是进行过音乐播放，vuex里面就保存播放的链接，而canplay方法会进行链接的判断，有链接就播放，因此每次刷新都会产生自动的播放。</p>
<p><strong>初次解决方法逻辑：</strong>通过刷新前，将vuex播放链接去掉，设置vuex中isPlay为false。</p>
<p><strong>这种逻辑存在的问题：</strong>刷新后，点击播放也无法进行播放了，因为链接为空。</p>
<p><strong>解决时间：</strong>2022/03/14</p>
<p><strong>解决方法：</strong>在与同学的讨论后，既然在刷新时已经把vuex中的isPlay设置为空，那就可以在canplay中播放音乐前对isPlay进行判断，isPlay为false就直接返回不走下面的逻辑。</p>
<p><strong>解决结果：</strong>实现了刷新后暂停音乐的播放，并且点击能继续播放</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>添加歌曲到歌单时局部刷新从新走create方法获取歌单数据，但子组件局部刷新会引起全局刷新。</p>
<p><strong>解决时间：</strong>2022/03/14</p>
<p><strong>解决方法：</strong>添加歌曲到歌单后再不做刷新了，而是调用完添加操作的接口后就直接再次请求获取歌单的接口进行数据刷新</p>
]]></content>
      <categories>
        <category>系统开发</category>
      </categories>
  </entry>
  <entry>
    <title>获取数组所有子集(算法)</title>
    <url>/2022/03/15/%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subCollection = getSubCollection(nums);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; sub : subCollection)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (Integer num : sub)&#123;</span><br><span class="line">                builder.append(num).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String str = builder.toString();</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(str.substring(<span class="number">0</span>,str.lastIndexOf(<span class="string">&#x27;,&#x27;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getSubCollection(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">//2^n - 1个子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span> &lt;&lt; len);i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; sub = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="comment">//取二进制中第j位，等于1就加进同一个子集，</span></span><br><span class="line">                /<span class="number">0</span>~<span class="number">2</span>^n-<span class="number">1</span>个数的二进制对应每一个子集</span><br><span class="line">                <span class="keyword">if</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                    sub.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[1]</span><br><span class="line">[2]</span><br><span class="line">[1,2]</span><br><span class="line">[3]</span><br><span class="line">[1,3]</span><br><span class="line">[2,3]</span><br><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
